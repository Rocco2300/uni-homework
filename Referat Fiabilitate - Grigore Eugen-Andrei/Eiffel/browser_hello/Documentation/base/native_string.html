<HTML><HEAD>
<meta name="description" content="TTTPlatform specific encoding of Unicode strings. By default, UTF-8 on unix or UTF-16 on Windows.  TTTMixed-encoding consideration TTT============================  TTTMost operating systems have conventions for strings that are incompatible with Unicode. TTTOn UNIX, a string is just a null-terminated byte sequence, it does not follow any TTTspecific encoding. Usually the locale setting enables you to see the string the way TTTyou expect. TTTOn Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows TTTdoes not guarantee that the sequence is actually a valid UTF-16 sequence.  TTTIn other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding TTTon Windows, the string is not directly representable as a Unicode string. To make it possible TTTto create and store strings in a textually representable form, the query `string' will create TTTan encoded representation that can be then later used in `make' to create a NATIVE_STRING TTTequivalent to the original string. The encoding is described in UTF_CONVERTER's note clause TTTand is a fourth variant of the recommended practice for replacement characters in Unicode TTT(see http://www.unicode.org/review/pr-121.html). "/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2020, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>native_string Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="native_string_chart.html">Chart</A></TD><TD><A HREF="native_string_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "[
        			Platform specific encoding of Unicode strings. By default, UTF-8 on unix or UTF-16 on Windows.
        
        			Mixed-encoding consideration
        			============================
        
        			Most operating systems have conventions for strings that are incompatible with Unicode.
        			On UNIX, a string is just a null-terminated byte sequence, it does not follow any
        			specific encoding. Usually the locale setting enables you to see the string the way
        			you expect.
        			On Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows
        			does not guarantee that the sequence is actually a valid UTF-16 sequence.
        
        			In other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding
        			on Windows, the string is not directly representable as a Unicode string. To make it possible
        			to create and store strings in a textually representable form, the query `<A HREF="../elks/native_string.html#f_string">string</A>` will create
        			an encoded representation that can be then later used in `<A HREF="../elks/native_string.html#f_make">make</A>` to create a NATIVE_STRING
        			equivalent to the original string. The encoding is described in UTF_CONVERTER's note clause
        			and is a fourth variant of the recommended practice for replacement characters in Unicode
        			(see <a href="http://www.unicode.org/review/pr-121.html">http://www.unicode.org/review/pr-121.html</a>).
        
    ]"
    date: "$Date: 2021-06-18 17:01:52 +0000 (Fri, 18 Jun 2021) $"
    revision: "$Revision: 105548 $"

<B>class</B> 
    <A HREF="../elks/native_string.html">NATIVE_STRING</A>

<B>inherit</B>
    <A HREF="../elks/native_string_handler.html">NATIVE_STRING_HANDLER</A>
        <B>redefine</B>
            <A HREF="../elks/native_string.html#f_is_equal">is_equal</A>
        <B>end</B>

<B>create</B> 
    <A HREF="../elks/native_string.html#f_make">make</A>,
    <A HREF="../elks/native_string.html#f_make_empty">make_empty</A>,
    <A HREF="../elks/native_string.html#f_make_from_pointer">make_from_pointer</A>,
    <A HREF="../elks/native_string.html#f_make_from_raw_string">make_from_raw_string</A>

<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_make"><A HREF="../elks/native_string.html#f_make">make</A> (a_string: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize an instance of Current using </FONT><I>a_string</I><FONT COLOR="red"> treated as a sequence</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of Unicode characters.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/native_string.html#f_make_empty">make_empty</A> (a_string.<A HREF="../elks/readable_string_general.html#f_count">count</A>)
            <A HREF="../elks/native_string.html#f_set_string">set_string</A> (a_string)
        <B>end</B></A>

    <A NAME="f_make_empty"><A HREF="../elks/native_string.html#f_make_empty">make_empty</A> (a_length: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize an empty instance of Current that will accommodate </FONT><I>a_length</I><FONT COLOR="red"> code units.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The memory area is not initialized.</FONT>
        <B>require</B>
            a_length_positive: a_length &gt;= 0
        <B>do</B>
            <B>create</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_make">make</A> ((a_length + 1) * <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
            <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> := 0
        <B>end</B></A>

    <A NAME="f_make_from_pointer"><A HREF="../elks/native_string.html#f_make_from_pointer">make_from_pointer</A> (a_pointer: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_pointer</I><FONT COLOR="red">, a platform system specific null-terminated string.</FONT>
        <B>require</B>
            a_path_pointer_not_null: a_pointer /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
        <B>local</B>
            l_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_count := <A HREF="../elks/native_string_handler.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_pointer)
            <B>create</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_make_from_pointer">make_from_pointer</A> (a_pointer, l_count + <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
            <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> := l_count // <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>
        <B>end</B></A>

    <A NAME="f_make_from_raw_string"><A HREF="../elks/native_string.html#f_make_from_raw_string">make_from_raw_string</A> (a_raw_string: <B>like</B> <A HREF="../elks/native_string.html#f_raw_string">raw_string</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_raw_string</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_raw_string_not_void: a_raw_string /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_make">make</A> (a_raw_string.<A HREF="../elks/readable_string_8.html#f_count">count</A> + <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
            <B>across</B>
                a_raw_string <B>as</B> l_c
            <B>loop</B>
                <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_put_character">put_character</A> (l_c, i)
                i := i + 1
            <B>end</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_put_natural_16">put_natural_16</A> (0, i)
            <B>else</B>
                <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_put_natural_8">put_natural_8</A> (0, i)
            <B>end</B>
            <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> := (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_count">count</A> - <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>) // <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>
        <B>ensure</B>
            set: <A HREF="../elks/native_string.html#f_raw_string">raw_string</A>.<A HREF="../elks/readable_string_8.html#f_same_string">same_string</A> (a_raw_string)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_raw_string"><A HREF="../elks/native_string.html#f_raw_string">raw_string</A>: <A HREF="../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Sequence of bytes representing </FONT><I>Current</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            l_cstr: <A HREF="../elks/c_string.html">C_STRING</A>
        <B>do</B>
            <B>create</B> l_cstr.<A HREF="../elks/c_string.html#f_make_shared_from_pointer_and_count">make_shared_from_pointer_and_count</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>, <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_count">count</A>)
            <B>Result</B> := l_cstr.<A HREF="../elks/c_string.html#f_substring_8">substring_8</A> (1, <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_count">count</A> - <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
        <B>end</B></A>

    <A NAME="f_string"><A HREF="../elks/native_string.html#f_string">string</A>: <A HREF="../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Representation of Current up to the first null character.</FONT>
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter.html#f_utf_16_0_pointer_to_escaped_string_32">utf_16_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>)
            <B>else</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter.html#f_utf_8_0_pointer_to_escaped_string_32">utf_8_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_substring"><A HREF="../elks/native_string.html#f_substring">substring</A> (start_pos, end_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Copy of substring containing all code units at indices</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> between </FONT><I>start_pos</I><FONT COLOR="red"> and </FONT><I>end_pos</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            start_position_big_enough: start_pos &gt;= 1
            end_position_big_enough: start_pos &lt;= end_pos + 1
            end_position_not_too_big: end_pos &lt;= (<A HREF="../elks/native_string.html#f_capacity">capacity</A> // <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_32.html#f_make">make</A> (end_pos - start_pos + 1)
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                u.<A HREF="../elks/utf_converter.html#f_utf_16_0_subpointer_into_escaped_string_32">utf_16_0_subpointer_into_escaped_string_32</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>, start_pos - 1, end_pos - 1, <B>False</B>, <B>Result</B>)
            <B>else</B>
                <B>Result</B> := u.<A HREF="../elks/utf_converter.html#f_utf_8_0_pointer_to_escaped_string_32">utf_8_0_pointer_to_escaped_string_32</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>);
                u.<A HREF="../elks/utf_converter.html#f_utf_8_0_subpointer_into_escaped_string_32">utf_8_0_subpointer_into_escaped_string_32</A> (<A HREF="../elks/native_string.html#f_managed_data">managed_data</A>, start_pos - 1, end_pos - 1, <B>False</B>, <B>Result</B>)
            <B>end</B>
        <B>ensure</B>
            susbstring_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_item"><A HREF="../elks/native_string.html#f_item">item</A>: <A HREF="../elks/pointer.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Get pointer to allocated area.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>
        <B>ensure</B>
            item_not_null: <B>Result</B> /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
        <B>end</B></A>

    <A NAME="f_managed_data"><A HREF="../elks/native_string.html#f_managed_data">managed_data</A>: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hold data of Current.</FONT>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status Report</FONT>

    <A NAME="f_is_empty"><A HREF="../elks/native_string.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current empty?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> = 0
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_capacity"><A HREF="../elks/native_string.html#f_capacity">capacity</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of bytes in Current.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_bytes_count"><A HREF="../elks/native_string.html#f_bytes_count">bytes_count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of bytes used by Current not including the null terminating character.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> * <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>
        <B>ensure</B>
            bytes_count_non_negative: <B>Result</B> &gt;= 0
        <B>end</B></A>

    <A NAME="f_unit_count"><A HREF="../elks/native_string.html#f_unit_count">unit_count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of units used by Current not including the null terminating unit.</FONT>

    <A NAME="f_unit_size"><A HREF="../elks/native_string.html#f_unit_size">unit_size</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Size in bytes of a unit for </FONT><I>storage</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := 2
            <B>else</B>
                <B>Result</B> := 1
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_is_equal"><A HREF="../elks/native_string.html#f_is_equal">is_equal</A> (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is content of string identical to content of string </FONT><I>other</I><FONT COLOR="red">?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/native_string.html#f_item">item</A>.<A HREF="../elks/pointer_ref.html#f_is_equal">is_equal</A> (other.<A HREF="../elks/native_string.html#f_item">item</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element change</FONT>

    <A NAME="f_set_string"><A HREF="../elks/native_string.html#f_set_string">set_string</A> (a_string: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/native_string.html#f_string">string</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> with </FONT><I>a_string</I><FONT COLOR="red">	treated as a sequence of Unicode characters.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/native_string.html#f_set_substring">set_substring</A> (a_string, 1, a_string.<A HREF="../elks/readable_string_general.html#f_count">count</A>)
        <B>end</B></A>

    <A NAME="f_set_substring"><A HREF="../elks/native_string.html#f_set_substring">set_substring</A> (a_string: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>; start_pos, end_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/native_string.html#f_string">string</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> with a subset of </FONT><I>a_string</I><FONT COLOR="red"> from </FONT><I>a_start_pos</I><FONT COLOR="red"> index to </FONT><I>end_pos</I><FONT COLOR="red"> index.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
            start_position_big_enough: start_pos &gt;= 1
            end_position_big_enough: start_pos &lt;= end_pos + 1
            end_pos_small_enough: end_pos &lt;= a_string.<A HREF="../elks/readable_string_general.html#f_count">count</A>
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                u.<A HREF="../elks/utf_converter.html#f_escaped_utf_32_substring_into_utf_16_0_pointer">escaped_utf_32_substring_into_utf_16_0_pointer</A> (a_string, start_pos, end_pos, <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>, 0, <A HREF="../elks/native_string.html#f_upper_cell">Upper_cell</A>)
            <B>else</B>
                u.<A HREF="../elks/utf_converter.html#f_escaped_utf_32_substring_into_utf_8_0_pointer">escaped_utf_32_substring_into_utf_8_0_pointer</A> (a_string, start_pos, end_pos, <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>, 0, <A HREF="../elks/native_string.html#f_upper_cell">Upper_cell</A>)
            <B>end</B>
            <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> := <A HREF="../elks/native_string.html#f_upper_cell">Upper_cell</A>.<A HREF="../elks/cell.html#f_item">item</A> // <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>
        <B>end</B></A>

    <A NAME="f_set_shared_from_pointer"><A HREF="../elks/native_string.html#f_set_shared_from_pointer">set_shared_from_pointer</A> (a_ptr: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New instance sharing </FONT><I>a_ptr</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
        <B>do</B>
            <A HREF="../elks/native_string.html#f_set_shared_from_pointer_and_count">set_shared_from_pointer_and_count</A> (a_ptr, <A HREF="../elks/native_string_handler.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_ptr))
        <B>end</B></A>

    <A NAME="f_set_shared_from_pointer_and_count"><A HREF="../elks/native_string.html#f_set_shared_from_pointer_and_count">set_shared_from_pointer_and_count</A> (a_ptr: <A HREF="../elks/pointer.html">POINTER</A>; a_length: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New instance sharing </FONT><I>a_ptr</I><FONT COLOR="red"> of </FONT><I>a_length</I><FONT COLOR="red"> byte. Space for an additional</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> null terminating code unit is added to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/native_string.html#f_managed_data">managed_data</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_ptr_not_null: a_ptr /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            a_length_non_negative: a_length &gt;= 0
            a_length_valid: (a_length \\ <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>) = 0
        <B>do</B>
            <A HREF="../elks/native_string.html#f_unit_count">unit_count</A> := a_length // <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>
            <B>if</B> <B>not</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_is_shared">is_shared</A> <B>then</B>
                <B>create</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_share_from_pointer">share_from_pointer</A> (a_ptr, a_length + <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
            <B>else</B>
                <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_set_from_pointer">set_from_pointer</A> (a_ptr, a_length + <A HREF="../elks/native_string.html#f_unit_size">unit_size</A>)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_platform"><A HREF="../elks/native_string.html#f_platform">Platform</A>: <A HREF="../elks/platform.html">PLATFORM</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access underlying platform info, used to satisfy invariant below.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_upper_cell"><A HREF="../elks/native_string.html#f_upper_cell">Upper_cell</A>: <A HREF="../elks/cell.html">CELL</A> [<A HREF="../elks/integer_32.html">INTEGER_32</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Temporary storage for byte index of last insertions when using UTF_CONVERTER routines.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/cell.html#f_put">put</A> (0)
        <B>end</B></A>
    
<B>invariant</B>
    little_endian_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/native_string.html#f_platform">Platform</A>.<A HREF="../elks/platform.html#f_is_little_endian">Is_little_endian</A>
    even_count_on_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/native_string.html#f_managed_data">managed_data</A>.<A HREF="../elks/managed_pointer.html#f_count">count</A> \\ <A HREF="../elks/native_string.html#f_unit_size">unit_size</A> = 0

<B>note</B>
    copyright: "Copyright (c) 1984-2020, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/native_string.html">NATIVE_STRING</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="native_string_chart.html">Chart</A></TD><TD><A HREF="native_string_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

