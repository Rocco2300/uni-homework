<HTML><HEAD>
<meta name="description" content="Hash tables, used to store items identified by hashable keys"/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="instructions" content="See instructions at the end of the class."/>
<meta name="warning" content="Modifying an object used as a key by an item present in a table will cause incorrect behavior. If you will be modifying key objects, pass a clone, not the object itself, as key argument to `put' and `replace_key'."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="instruction" content="TTSeveral procedures are provided for inserting an item TTwith a given key.  TTHere is how to choose between them:  TTT- Use `put' if you want to do an insertion only if TTT  there was no item with the given key, doing nothing TTT  otherwise. (You can find out on return if there was one, TTT  and what it was.)  TTT- Use `force' if you always want to insert the item; TTT  if there was one for the given key it will be removed, TTT  (and you can find out on return what it was).  TTT- Use `extend' if you are sure there is no item with TTT  the given key, enabling faster insertion (but TTT  unpredictable behavior if this assumption is not true).  TTT- Use `replace' if you want to replace an already present TTT  item with the given key, and do nothing if there is none.  TTIn addition you can use `replace_key' to change the key of an TTalready present item, identified by its previous key, or TTdo nothing if there is nothing for that previous key. TTYou can find out on return.  TTTo find out whether a key appears in the table, use `has'. TTTo find out the item, if any, associated with a certain key, TTuse `item'.  TTBoth of these routines perform a search. If you need TTboth pieces of information (does a key appear? And, if so, TTwhat is the associated item?), you can avoid performing TTtwo redundant traversals by using instead the combination TTof `search', `found' and `found_item' as follows:  TTTyour_table.search (your_key) TTTif your_table.found then TTTTwhat_you_where_looking_for := your_table.found_item TTTT... Do whatever is needed to `what_you_were_looking_for' ... TTTelse TTTT... No item was present for `your_key' ... TTTend"/>
<meta name="copyright" content="Copyright (c) 1984-2021, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>hash_table Chart</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD>Chart</TD><TD><A HREF="hash_table_links.html">Relations</A></TD><TD><A HREF="hash_table.html">Text</A></TD></TR></TABLE><B>class</B>
    <A HREF="../elks/hash_table_chart.html">HASH_TABLE</A> [G, K -&gt; <B>detachable</B> <A HREF="../elks/hashable_chart.html">HASHABLE</A>]

<B>General</B>
    cluster: <A HREF="../elks/index.html">elks</A>
    description: "Hash tables, used to store items identified by hashable keys"
    create: <A HREF="../elks/hash_table.html#f_make">make</A>, <A HREF="../elks/hash_table.html#f_make_equal">make_equal</A>, <A HREF="../elks/hash_table.html#f_make_from_iterable_tuples">make_from_iterable_tuples</A>

<B>Ancestors</B>
    <A HREF="../elks/dynamic_table_chart.html">DYNAMIC_TABLE</A>* [G, H]
    <A HREF="../elks/mismatch_corrector_chart.html">MISMATCH_CORRECTOR</A>
    <A HREF="../elks/readable_indexable_chart.html">READABLE_INDEXABLE</A>* [G]
    <A HREF="../elks/table_iterable_chart.html">TABLE_ITERABLE</A>* [G, K]
    <A HREF="../elks/unbounded_chart.html">UNBOUNDED</A>* [G]

<B>Queries</B>
    <A HREF="../elks/hash_table.html#f_after">after</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_at">at</A> <B>alias</B> "@" (key: K): <B>detachable</B> G
    <A HREF="../elks/hash_table.html#f_capacity">capacity</A>: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/container.html#f_changeable_comparison_criterion">changeable_comparison_criterion</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A><FONT COLOR="red"> -- (from CONTAINER)</FONT>
    <A HREF="../elks/hash_table.html#f_conflict">conflict</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_count">count</A>: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/hash_table.html#f_current_keys">current_keys</A>: <A HREF="../elks/array_chart.html">ARRAY</A> [K]
    <A HREF="../elks/hash_table.html#f_cursor">cursor</A>: <A HREF="../elks/cursor_chart.html">CURSOR</A>
    <A HREF="../elks/hash_table.html#f_definite_item">definite_item</A> (key: K): G
    <A HREF="../elks/hash_table.html#f_disjoint">disjoint</A> (other: <A HREF="../elks/hash_table_chart.html">HASH_TABLE</A> [G, K]): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_extendible">Extendible</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_found">found</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_found_item">found_item</A>: <B>detachable</B> G
    <A HREF="../elks/hash_table.html#f_full">Full</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_has">has</A> (key: K): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_has_item">has_item</A> (v: G): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_has_key">has_key</A> (key: K): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (a_key: <B>attached</B> K): <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/hash_table.html#f_inserted">inserted</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/finite.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A><FONT COLOR="red"> -- (from FINITE)</FONT>
    <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A> (other: [<B>like</B> <B>Current</B>] <A HREF="../elks/hash_table_chart.html">HASH_TABLE</A> [G, K]): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/collection.html#f_is_inserted">is_inserted</A> (v: G): <A HREF="../elks/boolean_chart.html">BOOLEAN</A><FONT COLOR="red"> -- (from COLLECTION)</FONT>
    <A HREF="../elks/hash_table.html#f_item">item</A> <B>alias</B> "[]" (key: K): <B>detachable</B> G
    <A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A>: G
    <A HREF="../elks/hash_table.html#f_iteration_item">iteration_item</A> (i: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>): G
    <A HREF="../elks/hash_table.html#f_iteration_lower">iteration_lower</A>: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/hash_table.html#f_iteration_upper">iteration_upper</A>: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/hash_table.html#f_key_for_iteration">key_for_iteration</A>: K
    <A HREF="../elks/hash_table.html#f_linear_representation">linear_representation</A>: <A HREF="../elks/arrayed_list_chart.html">ARRAYED_LIST</A> [G]
    <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>: <A HREF="../elks/mismatch_information_chart.html">MISMATCH_INFORMATION</A><FONT COLOR="red"> -- (from MISMATCH_CORRECTOR)</FONT>
    <A HREF="../elks/hash_table.html#f_new_cursor">new_cursor</A>: <A HREF="../elks/hash_table_iteration_cursor_chart.html">HASH_TABLE_ITERATION_CURSOR</A> [G, K]
    <A HREF="../elks/hash_table.html#f_not_found">not_found</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/container.html#f_object_comparison">object_comparison</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A><FONT COLOR="red"> -- (from CONTAINER)</FONT>
    <A HREF="../elks/hash_table.html#f_occurrences">occurrences</A> (v: G): <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>
    <A HREF="../elks/hash_table.html#f_off">off</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/dynamic_table.html#f_prunable">prunable</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A><FONT COLOR="red"> -- (from DYNAMIC_TABLE)</FONT>
    <A HREF="../elks/hash_table.html#f_removed">removed</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_replaced">replaced</A>: <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (a_search_key, a_key: K): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_valid_cursor">valid_cursor</A> (c: <A HREF="../elks/cursor_chart.html">CURSOR</A>): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>
    <A HREF="../elks/hash_table.html#f_valid_iteration_index">valid_iteration_index</A> (i: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>): <A HREF="../elks/boolean_chart.html">BOOLEAN</A>

<B>Commands</B>
    <A HREF="../elks/hash_table.html#f_accommodate">accommodate</A> (n: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>)
    <A HREF="../elks/table.html#f_bag_put">bag_put</A> (v: G)<FONT COLOR="red"> -- (from TABLE)</FONT>
    <A HREF="../elks/hash_table.html#f_collection_extend">collection_extend</A> (v: G)
    <A HREF="../elks/container.html#f_compare_objects">compare_objects</A><FONT COLOR="red"> -- (from CONTAINER)</FONT>
    <A HREF="../elks/container.html#f_compare_references">compare_references</A><FONT COLOR="red"> -- (from CONTAINER)</FONT>
    <A HREF="../elks/hash_table.html#f_copy">copy</A> (other: [<B>like</B> <B>Current</B>] <A HREF="../elks/hash_table_chart.html">HASH_TABLE</A> [G, K])
    <A HREF="../elks/hash_table.html#f_correct_mismatch">correct_mismatch</A>
    <A HREF="../elks/hash_table.html#f_extend">extend</A> (new: G; key: K)
    <A HREF="../elks/collection.html#f_fill">fill</A> (other: <A HREF="../elks/container_chart.html">CONTAINER</A> [G])<FONT COLOR="red"> -- (from COLLECTION)</FONT>
    <A HREF="../elks/hash_table.html#f_force">force</A> (new: G; key: K)
    <A HREF="../elks/hash_table.html#f_forth">forth</A>
    <A HREF="../elks/hash_table.html#f_go_to">go_to</A> (c: <A HREF="../elks/cursor_chart.html">CURSOR</A>)
    <A HREF="../elks/hash_table.html#f_make">make</A> (n: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>)
    <A HREF="../elks/hash_table.html#f_make_equal">make_equal</A> (n: <A HREF="../elks/integer_32_chart.html">INTEGER_32</A>)
    <A HREF="../elks/hash_table.html#f_make_from_iterable_tuples">make_from_iterable_tuples</A> (other: <A HREF="../elks/iterable_chart.html">ITERABLE</A> [<A HREF="../elks/tuple_chart.html">TUPLE</A> [G, K]])
    <A HREF="../elks/hash_table.html#f_merge">merge</A> (other: <A HREF="../elks/hash_table_chart.html">HASH_TABLE</A> [G, K])
    <A HREF="../elks/hash_table.html#f_prune">prune</A> (v: G)
    <A HREF="../elks/collection.html#f_prune_all">prune_all</A> (v: G)<FONT COLOR="red"> -- (from COLLECTION)</FONT>
    <A HREF="../elks/hash_table.html#f_put">put</A> (new: G; key: K)
    <A HREF="../elks/hash_table.html#f_remove">remove</A> (key: K)
    <A HREF="../elks/hash_table.html#f_replace">replace</A> (new: G; key: K)
    <A HREF="../elks/hash_table.html#f_replace_key">replace_key</A> (new_key, old_key: K)
    <A HREF="../elks/hash_table.html#f_search">search</A> (key: K)
    <A HREF="../elks/hash_table.html#f_start">start</A>
    <A HREF="../elks/hash_table.html#f_wipe_out">wipe_out</A>

<B>Constraints</B>
    keys not void
    content not void
    keys enough capacity
    content enough capacity
    valid iteration position
    control non negative
    special status
    count big enough
    count small enough
    slot count big enough

<TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD>Chart</TD><TD><A HREF="hash_table_links.html">Relations</A></TD><TD><A HREF="hash_table.html">Text</A></TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>
