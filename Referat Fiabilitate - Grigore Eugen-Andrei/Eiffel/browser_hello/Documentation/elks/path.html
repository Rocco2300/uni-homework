<HTML><HEAD>
<meta name="description" content="TTTObjects representing a path, i.e. a way to identify a file or a directory for the TTTcurrent underlying platform. A path is made of two components: TTT1 - an optional root which can either be: TTTTa - a drive letter followed by colon on Windows, i.e. C: or C:\ TTTTb - / for UNIX root directory. TTTTc - \ for Windows root directory. TTTTd - \\server\share or \\server\share\ for Microsoft UNC path. TTT2 - a sequence of zero or more names. TTT TTTA path is absolute if it has a root, and on windows if the root is a drive, then it should TTTbe followed by \. Otherwise a path is relative.   TTTValidity TTT======== TTT TTTThe current class will not check the validity of filenames. Check your file TTTsystem for your operating system manual for the list of invalid characters.   TTTWindows consideration TTT===================== TTT TTTWhen the root of a Windows path is a drive, be aware of the following behavior: TTT1 - C:filename.txt refers to the file name filename.txt in the current directory  TTT    on drive C:. TTT2 - C:sub\filename.txt refers to the file name filename.txt in a subdirectory sub TTT    of the current directory on drive C:. TTT3 - C:\sub\filename.txt refers to the file name filename.txt in a subdirectory sub TTT    located at the root of the drive C:. TTT TTTBoth forward and backslashes are accepted, but forward slashes are internally converted TTTto backward slashes whenever they are used to construct a path. TTT TTTOn Windows, there is a limit of 259 characters for a path. If you need to create a larger TTTpath, you can do so by using the following conventions which will let you have paths of TTTabout 32,767 characters: TTT1 - Use \\?\ for non-UNC path and let the rest unchanged. TTT2 - Use \\?\UNC\server\share for UNC path and let the rest unchanged. TTTThe above path cannot be used to specify a relative path. TTT TTTTo know more about Windows paths, read the Naming Files, Paths, and Namespaces TTTdocument located at: TTT  http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx   TTTUnicode consideration TTT===================== TTT TTTThe PATH class treats strings as sequence of Unicode characters, i.e. an instance of  TTTa READABLE_STRING_8 or descendant will be treated as if characters in the range TTT128 .. 255 were Unicode code points. TTTThis contrasts to the FILE/DIRECTORY classes where to preserve backward compatibility, those TTTcharacters are treated as is. TTT TTT TTTMixed-encoding consideration TTT============================ TTT TTTMost operating systems have conventions for paths that are incompatible with Unicode. TTTOn UNIX, in a sequence of names, each name is just a null-terminated byte sequence, it TTTdoes not follow any specific encoding. Usually the locale setting enables you to see TTTthe filename the way you expect. TTTOn Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows TTTdoes not guarantee that the sequence is actually a valid UTF-16 sequence. TTT TTTIn other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding TTTon Windows, the filename is not directly representable as a Unicode string. To make it possible TTTto create and store paths in a textually representable form, the query `name' will create TTTan encoded representation that can be then later used in `make_from_string' to create a PATH TTTequivalent to the original path. The encoding is described in UTF_CONVERTER's note clause TTTand is a fourth variant of the recommended practice for replacement characters in Unicode TTT(see http://www.unicode.org/review/pr-121.html).  TTTTTT TTTImmutability TTT============ TTT TTTInstances of the current class are immutable."/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2021, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>path Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="path_chart.html">Chart</A></TD><TD><A HREF="path_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "[
        			Objects representing a path, i.e. a way to identify a file or a directory for the
        			current underlying platform. A path is made of two components:
        			1 - an optional root which can either be:
        				a - a drive letter followed by colon on Windows, i.e. "C:" or "C:\"
        				b - "/" for UNIX root directory.
        				c - "\" for Windows root directory.
        				d - "\\server\share" or "\\server\share\" for Microsoft UNC path.
        			2 - a sequence of zero or more names.
        			
        			A path is absolute if it has a root, and on windows if the root is a drive, then it should
        			be followed by "\". Otherwise a path is relative.
        
        
        			Validity
        			========
        			
        			The current class will not check the validity of filenames. Check your file
        			system for your operating system manual for the list of invalid characters.
        
        
        			Windows consideration
        			=====================
        			
        			When the root of a Windows path is a drive, be aware of the following behavior:
        			1 - "C:filename.txt" refers to the file name "filename.txt" in the current directory 
        			    on drive "C:".
        			2 - "C:sub\filename.txt" refers to the file name "filename.txt" in a subdirectory "sub"
        			    of the current directory on drive "C:".
        			3 - "C:\sub\filename.txt" refers to the file name "filename.txt" in a subdirectory "sub"
        			    located at the root of the drive "C:".
        			
        			Both forward and backslashes are accepted, but forward slashes are internally converted
        			to backward slashes whenever they are used to construct a path.
        			
        			On Windows, there is a limit of 259 characters for a path. If you need to create a larger
        			path, you can do so by using the following conventions which will let you have paths of
        			about 32,767 characters:
        			1 - Use \\?\ for non-UNC path and let the rest unchanged.
        			2 - Use \\?\UNC\server\share for UNC path and let the rest unchanged.
        			The above path cannot be used to specify a relative path.
        			
        			To know more about Windows paths, read the "Naming Files, Paths, and Namespaces"
        			document located at:
        			  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247">http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247</a>(v=vs.85).aspx
        
        
        			Unicode consideration
        			=====================
        			
        			The PATH class treats strings as sequence of Unicode characters, i.e. an instance of 
        			a READABLE_STRING_8 or descendant will be treated as if characters in the range
        			128 .. 255 were Unicode code points.
        			This contrasts to the FILE/DIRECTORY classes where to preserve backward compatibility, those
        			characters are treated as is.
        			
        			
        			Mixed-encoding consideration
        			============================
        			
        			Most operating systems have conventions for paths that are incompatible with Unicode.
        			On UNIX, in a sequence of names, each name is just a null-terminated byte sequence, it
        			does not follow any specific encoding. Usually the locale setting enables you to see
        			the filename the way you expect.
        			On Windows, the sequence of names is made of null-terminated UTF-16 code unit sequence. Windows
        			does not guarantee that the sequence is actually a valid UTF-16 sequence.
        			
        			In other words, when there is an invalid UTF-8 encoding on UNIX, or an invalid UTF-16 encoding
        			on Windows, the filename is not directly representable as a Unicode string. To make it possible
        			to create and store paths in a textually representable form, the query `<A HREF="../elks/path.html#f_name">name</A>` will create
        			an encoded representation that can be then later used in `<A HREF="../elks/path.html#f_make_from_string">make_from_string</A>` to create a PATH
        			equivalent to the original path. The encoding is described in UTF_CONVERTER's note clause
        			and is a fourth variant of the recommended practice for replacement characters in Unicode
        			(see <a href="http://www.unicode.org/review/pr-121.html">http://www.unicode.org/review/pr-121.html</a>).
        
        						
        			Immutability
        			============
        			
        			Instances of the current class are immutable.
    ]"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    date: "$Date: 2021-05-31 11:01:25 +0000 (Mon, 31 May 2021) $"
    revision: "$Revision: 105458 $"

<B>class</B> 
    <A HREF="../elks/path.html">PATH</A>

<B>inherit</B>
    <A HREF="../elks/hashable.html">HASHABLE</A>
        <B>redefine</B>
            <A HREF="../elks/path.html#f_out">out</A>,
            <A HREF="../elks/path.html#f_is_equal">is_equal</A>,
            <A HREF="../elks/path.html#f_copy">copy</A>
        <B>end</B>

    <A HREF="../elks/comparable.html">COMPARABLE</A>
        <B>redefine</B>
            <A HREF="../elks/path.html#f_out">out</A>,
            <A HREF="../elks/path.html#f_is_equal">is_equal</A>,
            <A HREF="../elks/path.html#f_copy">copy</A>
        <B>end</B>

    <A HREF="../elks/native_string_handler.html">NATIVE_STRING_HANDLER</A>
        <B>redefine</B>
            <A HREF="../elks/path.html#f_out">out</A>,
            <A HREF="../elks/path.html#f_is_equal">is_equal</A>,
            <A HREF="../elks/path.html#f_copy">copy</A>
        <B>end</B>

    <A HREF="../elks/debug_output.html">DEBUG_OUTPUT</A>
        <B>redefine</B>
            <A HREF="../elks/path.html#f_out">out</A>,
            <A HREF="../elks/path.html#f_is_equal">is_equal</A>,
            <A HREF="../elks/path.html#f_copy">copy</A>
        <B>end</B>

<B>create</B> {<A HREF="../elks/native_string_handler.html">NATIVE_STRING_HANDLER</A>}
    <A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A>


<B>create</B> {<A HREF="../elks/path.html">PATH</A>}
    <A HREF="../elks/path.html#f_make_from_storage">make_from_storage</A>,
    <A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A>


<B>create</B> 
    <A HREF="../elks/path.html#f_make_empty">make_empty</A>,
    <A HREF="../elks/path.html#f_make_current">make_current</A>,
    <A HREF="../elks/path.html#f_make_from_string">make_from_string</A>,
    <A HREF="../elks/path.html#f_make_from_separate">make_from_separate</A>

<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_make_empty"><A HREF="../elks/path.html#f_make_empty">make_empty</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current as an empty path.</FONT>
        <B>do</B>
            <B>create</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_general.html#f_make_empty">make_empty</A>
            <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            is_empty: <A HREF="../elks/path.html#f_is_empty">is_empty</A>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>end</B></A>

    <A NAME="f_make_current"><A HREF="../elks/path.html#f_make_current">make_current</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current as the symbolic representation of the current working directory</FONT>
        <B>do</B>
            <B>create</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_unit_size">unit_size</A>);
            <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_append_character">append_character</A> ('.')
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_append_character">append_character</A> ('%U')
            <B>end</B>
            <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            not_empty: <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
            is_current: <A HREF="../elks/path.html#f_is_current_symbol">is_current_symbol</A>
        <B>end</B></A>

    <A NAME="f_make_from_string"><A HREF="../elks/path.html#f_make_from_string">make_from_string</A> (a_path: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_path</I><FONT COLOR="red"> treated as a sequence of Unicode characters.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If </FONT><I>a_path</I><FONT COLOR="red"> is trying to represent a mixed-encoded path, then </FONT><I>a_path</I><FONT COLOR="red"> should use</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> the escaped representation as described in UTF_CONVERTER.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
        <B>do</B>
            <B>create</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_make">make</A> (a_path.<A HREF="../elks/readable_string_general.html#f_count">count</A> * <A HREF="../elks/path.html#f_unit_size">unit_size</A>)
            <B>if</B> <B>not</B> a_path.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A> <B>then</B>
                <A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (<A HREF="../elks/path.html#f_storage">storage</A>, a_path, '%U')
                <A HREF="../elks/path.html#f_normalize">normalize</A>
            <B>else</B>
                <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <B>end</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            not_empty: <B>not</B> a_path.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A> <B>implies</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
            roundtrip: <B>True</B>
            roundtrip_with_trailing: <B>True</B>
        <B>end</B></A>

    <A NAME="f_make_from_separate"><A HREF="../elks/path.html#f_make_from_separate">make_from_separate</A> (a_path: <B>separate</B> <A HREF="../elks/path.html">PATH</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize from separate </FONT><I>a_path</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
        <B>do</B>
            <B>create</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_make_from_separate">make_from_separate</A> (a_path.<A HREF="../elks/path.html#f_storage">storage</A>)
            <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            not_empty: <B>not</B> a_path.<A HREF="../elks/path.html#f_is_empty">is_empty</A> <B>implies</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Internal initialization</FONT>

    <A NAME="f_make_from_storage"><A HREF="../elks/path.html#f_make_from_storage">make_from_storage</A> (a_path: <A HREF="../elks/string_8.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_path</I><FONT COLOR="red"> and normalize </FONT><I>a_path</I><FONT COLOR="red"> as it may be coming</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> from a user provided string or from a C API.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/path.html#f_storage">storage</A> := a_path
            <A HREF="../elks/path.html#f_normalize">normalize</A>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            shared: <A HREF="../elks/path.html#f_storage">storage</A> = a_path
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>end</B></A>

    <A NAME="f_make_from_normalized_storage"><A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (a_path: <A HREF="../elks/string_8.html">STRING_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_path</I><FONT COLOR="red"> which has already been normalized.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/path.html#f_storage">storage</A> := a_path
            <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>ensure</B>
            shared: <A HREF="../elks/path.html#f_storage">storage</A> = a_path
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>end</B></A>

    <A NAME="f_make_from_pointer"><A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A> (a_path_pointer: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize current from </FONT><I>a_path_pointer</I><FONT COLOR="red">, a platform system specific encoding of</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> a path that is null-terminated.</FONT>
        <B>require</B>
            a_path_pointer_not_null: a_path_pointer /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
        <B>local</B>
            l_cstr: <A HREF="../elks/c_string.html">C_STRING</A>
            nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            nb := <A HREF="../elks/native_string_handler.html#f_pointer_length_in_bytes">pointer_length_in_bytes</A> (a_path_pointer)
            nb := nb - nb \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A>
            <B>create</B> l_cstr.<A HREF="../elks/c_string.html#f_make_shared_from_pointer_and_count">make_shared_from_pointer_and_count</A> (a_path_pointer, nb)
            <A HREF="../elks/path.html#f_storage">storage</A> := l_cstr.<A HREF="../elks/c_string.html#f_substring_8">substring_8</A> (1, nb)
            <B>if</B> <B>not</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <A HREF="../elks/path.html#f_normalize">normalize</A>
            <B>end</B>
            <A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_is_current_symbol"><A HREF="../elks/path.html#f_is_current_symbol">is_current_symbol</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is Current a representation of "."?</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> = <A HREF="../elks/path.html#f_unit_size">unit_size</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1, '.')
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_parent_symbol"><A HREF="../elks/path.html#f_is_parent_symbol">is_parent_symbol</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is Current Representation of ".."?</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> = 2 * <A HREF="../elks/path.html#f_unit_size">unit_size</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1, '.')
                <B>Result</B> := <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1 + <A HREF="../elks/path.html#f_unit_size">unit_size</A>, '.')
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_has_root"><A HREF="../elks/path.html#f_has_root">has_root</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does current have a root?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A> /= 0
        <B>ensure</B>
            defintion: <B>Result</B> <B>implies</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_is_empty"><A HREF="../elks/path.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current empty, i.e. no root and no sequence of names?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_is_relative"><A HREF="../elks/path.html#f_is_relative">is_relative</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current path relative?</FONT>
        <B>do</B>
            <B>Result</B> := <B>not</B> <A HREF="../elks/path.html#f_is_absolute">is_absolute</A>
        <B>end</B></A>

    <A NAME="f_is_absolute"><A HREF="../elks/path.html#f_is_absolute">is_absolute</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current path absolute?</FONT>
        <B>local</B>
            l_root_end_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_root_end_position := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
            <B>if</B> l_root_end_position &gt; 0 <B>then</B>
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, l_root_end_position - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                <B>else</B>
                    <B>Result</B> := <B>True</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_simple"><A HREF="../elks/path.html#f_is_simple">is_simple</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current path made of only one name and no root?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> I.e. readme.txt, usr or the empty path.</FONT>
        <B>local</B>
            l_root_pos: <B>like</B> <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <B>Result</B> := <B>True</B>
            <B>else</B>
                l_root_pos := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
                <B>if</B> l_root_pos = 0 <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (1) = 0
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_same_file_as"><A HREF="../elks/path.html#f_is_same_file_as">is_same_file_as</A> (a_path: <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does </FONT><I>Current</I><FONT COLOR="red"> and </FONT><I>a_path</I><FONT COLOR="red"> points to the same file on disk? It is different from path equality</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> as it will take into account symbolic links.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If </FONT><I>Current</I><FONT COLOR="red"> or/and </FONT><I>a_path</I><FONT COLOR="red"> do not exists, it will yield false, otherwise it will compare</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> the file at the file system level.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
        <B>local</B>
            l_p1, l_p2: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
        <B>do</B>
            l_p1 := <A HREF="../elks/path.html#f_to_pointer">to_pointer</A>
            l_p2 := a_path.<A HREF="../elks/path.html#f_to_pointer">to_pointer</A>
            <B>Result</B> := <A HREF="../elks/path.html#f_c_same_files">c_same_files</A> (l_p1.<A HREF="../elks/managed_pointer.html#f_item">item</A>, l_p2.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_has_extension"><A HREF="../elks/path.html#f_has_extension">has_extension</A> (a_ext: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does </FONT><I>Current</I><FONT COLOR="red"> has an extension </FONT><I>a_ext</I><FONT COLOR="red"> compared in a case insensitive manner?</FONT>
        <B>require</B>
            a_ext_not_void: a_ext /= <B>Void</B>
            a_ext_not_empty: <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A>
            a_ext_has_no_dot: <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_has">has</A> ('.'.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>)
        <B>do</B>
            <B>Result</B> := <B>attached</B> <A HREF="../elks/path.html#f_extension">extension</A> <B>as</B> l_ext <B>and then</B> l_ext.<A HREF="../elks/readable_string_general.html#f_is_case_insensitive_equal">is_case_insensitive_equal_general</A> (a_ext)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_root"><A HREF="../elks/path.html#f_root">root</A>: <B>detachable</B> <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Root if any of current path.</FONT>
        <B>local</B>
            l_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_pos := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
            <B>if</B> l_pos /= 0 <B>then</B>
                <B>if</B> l_pos = <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
                <B>else</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (1, l_pos))
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            has_root_implies_not_void: <A HREF="../elks/path.html#f_has_root">has_root</A> <B>implies</B> <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_parent"><A HREF="../elks/path.html#f_parent">parent</A>: <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Parent directory if any, otherwise current working path.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The parent of a path consists of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_root">root</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if any, and of each</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> simple names in the current sequence except for the last.</FONT>
        <B>local</B>
            l_pos, l_root_end_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_pos := <A HREF="../elks/path.html#f_end_position_of_last_directory_separator">end_position_of_last_directory_separator</A>
            <B>if</B> l_pos = 0 <B>then</B>
                <B>if</B> <B>attached</B> <A HREF="../elks/path.html#f_root">root</A> <B>as</B> l_root <B>then</B>
                    <B>check</B>
                        is_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A>
                    <B>end</B>
                    <B>Result</B> := l_root
                <B>else</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_current">make_current</A>
                <B>end</B>
            <B>elseif</B> l_pos = <A HREF="../elks/path.html#f_unit_size">unit_size</A> <B>then</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (1, <A HREF="../elks/path.html#f_unit_size">unit_size</A>))
            <B>else</B>
                l_root_end_pos := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
                <B>if</B> l_pos &lt;= l_root_end_pos <B>then</B>
                    <B>if</B> l_root_end_pos = <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                        <B>Result</B> := <B>Current</B>
                    <B>else</B>
                        <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (1, l_root_end_pos))
                    <B>end</B>
                <B>else</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (1, l_pos - <A HREF="../elks/path.html#f_unit_size">unit_size</A>))
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_entry"><A HREF="../elks/path.html#f_entry">entry</A>: <B>detachable</B> <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Name of file or directory denoted by Current if any.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> This is the last name in the current sequence.</FONT>
        <B>local</B>
            l_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_end_root: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_pos := <A HREF="../elks/path.html#f_end_position_of_last_directory_separator">end_position_of_last_directory_separator</A>
            <B>if</B> l_pos = 0 <B>then</B>
                l_end_root := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
                <B>if</B> l_end_root &gt; 0 <B>then</B>
                    <B>if</B> l_end_root &lt; <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                        <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (l_end_root + 1, <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>))
                    <B>end</B>
                <B>else</B>
                    <B>Result</B> := <B>Current</B>
                <B>end</B>
            <B>else</B>
                l_end_root := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
                <B>if</B> l_pos &lt;= l_end_root <B>then</B>
                    <B>if</B> l_end_root &lt; <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                        <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (l_end_root + 1, <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>))
                    <B>end</B>
                <B>else</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_substring">substring</A> (l_pos + 1, <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>))
                <B>end</B>
            <B>end</B>
            <B>if</B> <B>Result</B> /= <B>Void</B> <B>and then</B> (<B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A> <B>or</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_current_symbol">is_current_symbol</A> <B>or</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_parent_symbol">is_parent_symbol</A>) <B>then</B>
                <B>Result</B> := <B>Void</B>
            <B>end</B>
        <B>ensure</B>
            not_empty: <B>Result</B> /= <B>Void</B> <B>implies</B> <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_extension"><A HREF="../elks/path.html#f_extension">extension</A>: <B>detachable</B> <A HREF="../elks/immutable_string_32.html">IMMUTABLE_STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Extension if any of current entry.</FONT>
        <B>local</B>
            l_name: <B>like</B> <A HREF="../elks/path.html#f_name">name</A>
            l_pos, nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <B>attached</B> <A HREF="../elks/path.html#f_entry">entry</A> <B>as</B> l_entry <B>then</B>
                l_name := l_entry.<A HREF="../elks/path.html#f_name">name</A>
                nb := l_name.<A HREF="../elks/readable_string_32.html#f_count">count</A>
                l_pos := l_name.<A HREF="../elks/readable_string_32.html#f_last_index_of">last_index_of</A> ('.'.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>, nb)
                <B>if</B> l_pos /= 0 <B>and</B> l_pos /= nb <B>then</B>
                    <B>Result</B> := l_name.<A HREF="../elks/immutable_string_32.html#f_shared_substring">shared_substring</A> (l_pos + 1, nb)
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            not_empty: <B>attached</B> <B>Result</B> <B>implies</B> <B>not</B> <B>Result</B>.<A HREF="../elks/immutable_string_32.html#f_is_empty">is_empty</A>
            no_dot: <B>attached</B> <B>Result</B> <B>implies</B> <B>not</B> <B>Result</B>.<A HREF="../elks/readable_string_32.html#f_has">has</A> ('.'.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>)
        <B>end</B></A>

    <A NAME="f_components"><A HREF="../elks/path.html#f_components">components</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/path.html">PATH</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Sequence of simple paths making up Current, including </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_root">root</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if any.</FONT>
        <B>local</B>
            l_storage: <A HREF="../elks/string_8.html">STRING_8</A>
            l_previous_pos, l_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (10)
            l_pos := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
            <B>if</B> l_pos &gt; 0 <B>then</B>
                <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (l_pos);
                l_storage.<A HREF="../elks/string_8.html#f_append_substring">append_substring</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1, l_pos);
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage) <B>end</B>)
                l_pos := l_pos + 1
            <B>else</B>
                l_pos := 1
            <B>end</B>
            <B>if</B> l_pos &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                <B>from</B>
                    l_previous_pos := l_pos
                    l_pos := <A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (l_previous_pos)
                <B>until</B>
                    l_pos = 0
                <B>loop</B>
                    <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (l_pos - l_previous_pos);
                    l_storage.<A HREF="../elks/string_8.html#f_append_substring">append_substring</A> (<A HREF="../elks/path.html#f_storage">storage</A>, l_previous_pos, l_pos - 1);
                    <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage) <B>end</B>)
                    l_previous_pos := l_pos + <A HREF="../elks/path.html#f_unit_size">unit_size</A>
                    l_pos := <A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (l_previous_pos)
                <B>end</B>
                <B>if</B> l_previous_pos &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                    <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> - l_previous_pos);
                    l_storage.<A HREF="../elks/string_8.html#f_append_substring">append_substring</A> (<A HREF="../elks/path.html#f_storage">storage</A>, l_previous_pos, <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>);
                    <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage) <B>end</B>)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_absolute_path"><A HREF="../elks/path.html#f_absolute_path">absolute_path</A>: <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Absolute path of Current.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If Current is already absolute, then return Current.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If Current is empty, then return the current working directory.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Otherwise resolve the path in a platform specific way:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> * On UNIX, resolve against the current working directory</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> * On Windows:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">    a) if current has a drive letter which is not followed by "\"</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       resolve against the current working directory for that drive letter,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       otherwise resolve against the current working directory.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">    b) if current path starts with "\", not a double "\\", then resolve</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       against the root of the current working directory (i.e. a drive</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       letter "C:\" or a UNC path "\\server\share\".)</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/path.html#f_absolute_path_in">absolute_path_in</A> (<A HREF="../elks/path.html#f_env">Env</A>.<A HREF="../elks/execution_environment.html#f_current_working_path">current_working_path</A>)
        <B>end</B></A>

    <A NAME="f_absolute_path_in"><A HREF="../elks/path.html#f_absolute_path_in">absolute_path_in</A> (a_current_directory: <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Absolute path of Current in the context of </FONT><I>a_current_directory</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If Current is already absolute, then return Current.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If Current is empty, then return </FONT><I>a_current_directory</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Otherwise resolve the path in a platform specific way:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> * On UNIX, resolve against </FONT><I>a_current_directory</I>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> * On Windows:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">    a) if current has a drive letter which is not followed by "\"</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       resolve against </FONT><I>a_current_directory</I><FONT COLOR="red"> for that drive letter,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       otherwise resolve against </FONT><I>a_current_directory</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">    b) if current path starts with "\", not a double "\\", then resolve</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       against the root of `a_current_directory; (i.e. a drive</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">       letter "C:\" or a UNC path "\\server\share\".)</FONT>
        <B>require</B>
            a_current_directory_not_void: a_current_directory /= <B>Void</B>
            a_current_directory_absolute: a_current_directory.<A HREF="../elks/path.html#f_is_absolute">is_absolute</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <B>Result</B> := a_current_directory
            <B>else</B>
                <B>if</B> <A HREF="../elks/path.html#f_is_absolute">is_absolute</A> <B>then</B>
                    <B>Result</B> := <B>Current</B>
                <B>else</B>
                    <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                        <B>if</B> <B>attached</B> <A HREF="../elks/path.html#f_root">root</A> <B>as</B> l_root <B>then</B>
                            <B>if</B> (l_root.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> = 4 <B>and</B> a_current_directory.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt;= 4) <B>and then</B> (l_root.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (1) = a_current_directory.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (1) <B>and</B> l_root.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (3) = a_current_directory.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (3)) <B>then</B>
                                <B>Result</B> := a_current_directory.<A HREF="../elks/any.html#f_twin">twin</A>
                            <B>else</B>
                                <B>Result</B> := l_root
                            <B>end</B>
                            <A HREF="../elks/path.html#f_internal_path_append_substring_into">internal_path_append_substring_into</A> (<B>Result</B>.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_storage">storage</A>, l_root.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + 1, <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                        <B>else</B>
                            <B>if</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>then</B>
                                <B>Result</B> := a_current_directory.<A HREF="../elks/any.html#f_twin">twin</A>
                                <B>if</B> <B>attached</B> <B>Result</B>.<A HREF="../elks/path.html#f_root">root</A> <B>as</B> l_root <B>then</B>
                                    <B>Result</B> := l_root
                                <B>end</B>
                            <B>else</B>
                                <B>Result</B> := a_current_directory.<A HREF="../elks/any.html#f_twin">twin</A>
                            <B>end</B>
                            <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (<B>Result</B>.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                        <B>end</B>
                    <B>else</B>
                        <B>Result</B> := a_current_directory.<A HREF="../elks/any.html#f_twin">twin</A>
                        <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (<B>Result</B>.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                    <B>end</B>;
                    <B>Result</B>.<A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            has_root: <B>Result</B>.<A HREF="../elks/path.html#f_has_root">has_root</A>
        <B>end</B></A>

    <A NAME="f_canonical_path"><A HREF="../elks/path.html#f_canonical_path">canonical_path</A>: <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Canonical path of Current.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Similar to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_absolute_path">absolute_path</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> except that sequences containing "." or ".." are</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> resolved.</FONT>
        <B>local</B>
            l_components: <B>like</B> <A HREF="../elks/path.html#f_components">components</A>
            l_absolute_path: <B>like</B> <A HREF="../elks/path.html#f_absolute_path">absolute_path</A>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            l_absolute_path := <A HREF="../elks/path.html#f_absolute_path">absolute_path</A>
            <B>if</B> <B>attached</B> l_absolute_path.<A HREF="../elks/path.html#f_root">root</A> <B>as</B> l_root <B>then</B>
                <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (l_absolute_path.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>)
                l_components := l_absolute_path.<A HREF="../elks/path.html#f_components">components</A>
                <B>check</B>
                    l_components_has_root: l_components.<A HREF="../elks/arrayed_list.html#f_count">count</A> &gt;= 1
                    l_components_first_is_root: l_components.<A HREF="../elks/arrayed_list.html#f_first">first</A>.<A HREF="../elks/path.html#f_same_as">same_as</A> (l_root)
                <B>end</B>
                <B>from</B>
                    l_components.<A HREF="../elks/arrayed_list.html#f_start">start</A>
                    <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (l_storage, l_components.<A HREF="../elks/arrayed_list.html#f_item">item</A>.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>);
                    l_components.<A HREF="../elks/arrayed_list.html#f_remove">remove</A>
                <B>until</B>
                    l_components.<A HREF="../elks/list.html#f_after">after</A>
                <B>loop</B>
                    <B>if</B> l_components.<A HREF="../elks/arrayed_list.html#f_item">item</A>.<A HREF="../elks/path.html#f_is_current_symbol">is_current_symbol</A> <B>then</B>
                        l_components.<A HREF="../elks/arrayed_list.html#f_remove">remove</A>
                    <B>elseif</B> l_components.<A HREF="../elks/arrayed_list.html#f_item">item</A>.<A HREF="../elks/path.html#f_is_parent_symbol">is_parent_symbol</A> <B>then</B>
                        <B>if</B> <B>not</B> l_components.<A HREF="../elks/chain.html#f_isfirst">isfirst</A> <B>then</B>
                            l_components.<A HREF="../elks/arrayed_list.html#f_back">back</A>;
                            l_components.<A HREF="../elks/arrayed_list.html#f_remove">remove</A>
                        <B>end</B>;
                        l_components.<A HREF="../elks/arrayed_list.html#f_remove">remove</A>
                    <B>else</B>
                        l_components.<A HREF="../elks/arrayed_list.html#f_forth">forth</A>
                    <B>end</B>
                <B>end</B>
                <B>across</B>
                    l_components <B>as</B> c
                <B>loop</B>
                    <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (l_storage, c.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                <B>end</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage)
            <B>else</B>
                <B>check</B>
                    <B>False</B>
                <B>end</B>
                <B>Result</B> := l_absolute_path
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_hash_code"><A HREF="../elks/path.html#f_hash_code">hash_code</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash code value</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/operating_environment.html">OPERATING_ENVIRONMENT</A>}.<A HREF="../elks/operating_environment.html#f_case_sensitive_path_names">case_sensitive_path_names</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_general.html#f_hash_code">hash_code</A>
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_general.html#f_case_insensitive_hash_code">case_insensitive_hash_code</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_native_string"><A HREF="../elks/path.html#f_native_string">native_string</A>: <A HREF="../elks/native_string.html">NATIVE_STRING</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Convert current into an instance of NATIVE_STRING</FONT>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/native_string.html#f_make_from_raw_string">make_from_raw_string</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
        <B>ensure</B>
            set: <B>Result</B>.<A HREF="../elks/native_string.html#f_raw_string">raw_string</A>.<A HREF="../elks/readable_string_8.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
        <B>end</B></A>

    <A NAME="f_unix_separator"><A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>: <A HREF="../elks/character_8.html">CHARACTER_8</A> = '/'</A>

    <A NAME="f_windows_separator"><A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>: <A HREF="../elks/character_8.html">CHARACTER_8</A> = '\'</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Platform specific directory separator.</FONT>

    <A NAME="f_directory_separator"><A HREF="../elks/path.html#f_directory_separator">directory_separator</A>: <A HREF="../elks/character_8.html">CHARACTER_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default directory separator for the current platform.</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status setting</FONT>

    <A NAME="f_extended"><A HREF="../elks/path.html#f_extended">extended</A> (a_name: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New path instance of current extended with path </FONT><I>a_name</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If current is not empty, then </FONT><I>a_name</I><FONT COLOR="red"> cannot have a root.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> A directory separator is added between two entries except</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 1 - </FONT><I>a_name</I><FONT COLOR="red"> starts with a directory separator (i.e. it has a root)</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 2 - if current is empty or is just a root.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Note that </FONT><I>a_name</I><FONT COLOR="red"> can be an encoding of a mixed-encoding simple name and it will</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> be decoded accordingly (see note clause for the class for more details.)</FONT>
        <B>require</B>
            a_name_not_void: a_name /= <B>Void</B>
            a_name_not_empty: <B>not</B> a_name.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A>
            a_name_has_no_root: <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A> <B>end</B> <B>end</B> <B>implies</B>  <B>end</B><B>not</B> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_string">make_from_string</A> (a_name) <B>end</B>).<A HREF="../elks/path.html#f_has_root">has_root</A>
        <B>local</B>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + a_name.<A HREF="../elks/readable_string_general.html#f_count">count</A> * <A HREF="../elks/path.html#f_unit_size">unit_size</A> + <A HREF="../elks/path.html#f_unit_size">unit_size</A>);
            l_storage.<A HREF="../elks/string_8.html#f_append">append</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
            <B>if</B> l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt; 0 <B>and</B> <A HREF="../elks/path.html#f_root_end_position">root_end_position</A> = l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                <A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (l_storage, a_name, '%U')
            <B>else</B>
                <A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (l_storage, a_name, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
            <B>end</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_storage">make_from_storage</A> (l_storage)
        <B>ensure</B>
            associated_path_of_name: <B>attached</B> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_string">make_from_string</A> (a_name) <B>end</B>) <B>as</B> l_path
            not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            extended_with_only_empty_or_root: (<A HREF="../elks/path.html#f_same_as">same_as</A> (<A HREF="../elks/path.html#f_root">root</A>) <B>or</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>) <B>implies</B> <B>Result</B>.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_name">name</A> + l_path.<A HREF="../elks/path.html#f_name">name</A>)
            extended_with_more_than_root_or_not_empty: (<B>not</B> <A HREF="../elks/path.html#f_same_as">same_as</A> (<A HREF="../elks/path.html#f_root">root</A>) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>) <B>implies</B> <B>Result</B>.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_name">name</A> + <A HREF="../elks/path.html#f_directory_separator_string">Directory_separator_string</A> + l_path.<A HREF="../elks/path.html#f_name">name</A>)
        <B>end</B></A>

    <A NAME="f_extended_path"><A HREF="../elks/path.html#f_extended_path">extended_path</A> <B>alias</B> "+" (a_path: <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New path instance of current extended with path </FONT><I>a_path</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If current is not empty, then </FONT><I>a_path</I><FONT COLOR="red"> cannot have a root.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> A directory separator is added between two entries except</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 1 - </FONT><I>a_path</I><FONT COLOR="red"> starts with a directory separator (i.e. it has a root)</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 2 - if current is empty or is just a root.</FONT>
        <B>require</B>
            a_path_not_void: a_path /= <B>Void</B>
            a_path_not_empty: <B>not</B> a_path.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            a_path_has_no_root: <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A> <B>implies</B> <B>not</B> a_path.<A HREF="../elks/path.html#f_has_root">has_root</A>
        <B>local</B>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + a_path.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + <A HREF="../elks/path.html#f_unit_size">unit_size</A>);
            l_storage.<A HREF="../elks/string_8.html#f_append">append</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
            <B>if</B> l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt; 0 <B>and</B> <A HREF="../elks/path.html#f_root_end_position">root_end_position</A> = l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (l_storage, a_path.<A HREF="../elks/path.html#f_storage">storage</A>, '%U')
            <B>else</B>
                <A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (l_storage, a_path.<A HREF="../elks/path.html#f_storage">storage</A>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
            <B>end</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage)
        <B>ensure</B>
            not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            extended_with_only_empty_or_root: (<A HREF="../elks/path.html#f_same_as">same_as</A> (<A HREF="../elks/path.html#f_root">root</A>) <B>or</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>) <B>implies</B> <B>Result</B>.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_name">name</A> + a_path.<A HREF="../elks/path.html#f_name">name</A>)
            extended_with_more_than_root_or_not_empty: (<B>not</B> <A HREF="../elks/path.html#f_same_as">same_as</A> (<A HREF="../elks/path.html#f_root">root</A>) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_empty">is_empty</A>) <B>implies</B> <B>Result</B>.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_name">name</A> + <A HREF="../elks/path.html#f_directory_separator_string">Directory_separator_string</A> + a_path.<A HREF="../elks/path.html#f_name">name</A>)
        <B>end</B></A>

    <A NAME="f_appended"><A HREF="../elks/path.html#f_appended">appended</A> (a_extra: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New path instance of current where </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_entry">entry</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> is appended with </FONT><I>a_extra</I><FONT COLOR="red"> without</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> adding a directory separator.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> For example if Current path is "C:" and </FONT><I>a_path</I><FONT COLOR="red"> is "path\file.txt", it will yield</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> "C:path\file.txt".</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Note that </FONT><I>a_extra</I><FONT COLOR="red"> can be an encoding of a mixed-encoding simple name and it will</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> be decoded accordingly (see note clause for the class for more details.)</FONT>
        <B>require</B>
            a_extra_not_void: a_extra /= <B>Void</B>
            a_extra_not_empty: <B>not</B> a_extra.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A>
        <B>local</B>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + a_extra.<A HREF="../elks/readable_string_general.html#f_count">count</A> * <A HREF="../elks/path.html#f_unit_size">unit_size</A>);
            l_storage.<A HREF="../elks/string_8.html#f_append">append</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
            <A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (l_storage, a_extra, '%U')
            <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_storage">make_from_storage</A> (l_storage)
        <B>ensure</B>
            not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            appended: <B>Result</B>.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_same_string">same_string</A> (<A HREF="../elks/path.html#f_name">name</A> <B>end</B> + (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_string">make_from_string</A> (a_extra) <B>end</B>).<A HREF="../elks/path.html#f_name">name</A>)
        <B>end</B></A>

    <A NAME="f_appended_with_extension"><A HREF="../elks/path.html#f_appended_with_extension">appended_with_extension</A> (a_ext: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New path instance of current where </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_entry">entry</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> is extended with a dot followed by </FONT><I>a_ext</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If Current already has a dot, no dot is added.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Note that </FONT><I>a_ext</I><FONT COLOR="red"> can be an encoding of a mixed-encoding simple name and it will</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> be decoded accordingly (see note clause for the class for more details.)</FONT>
        <B>require</B>
            a_ext_not_void: a_ext /= <B>Void</B>
            a_ext_not_empty: <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A>
            a_ext_has_no_dot: <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_has">has</A> ('.'.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>)
            a_ext_has_no_directory_separator: <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_has">has</A> (<A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>) <B>and</B> <B>not</B> a_ext.<A HREF="../elks/readable_string_general.html#f_has">has</A> (<A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A>)
            has_entry: <A HREF="../elks/path.html#f_entry">entry</A> /= <B>Void</B>
        <B>local</B>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            <B>create</B> l_storage.<A HREF="../elks/readable_string_8.html#f_make">make</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + a_ext.<A HREF="../elks/readable_string_general.html#f_count">count</A> * <A HREF="../elks/path.html#f_unit_size">unit_size</A> + <A HREF="../elks/path.html#f_unit_size">unit_size</A>);
            l_storage.<A HREF="../elks/string_8.html#f_append">append</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
            <A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (l_storage, a_ext, '.')
            <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_normalized_storage">make_from_normalized_storage</A> (l_storage)
        <B>ensure</B>
            not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            extension_set: <B>attached</B> <B>Result</B>.<A HREF="../elks/path.html#f_extension">extension</A> <B>as</B> l_ext <B>and then</B> l_ext.<A HREF="../elks/readable_string_general.html#f_same_string">same_string_general</A> (a_ext)
            components_stable: <B>Result</B>.<A HREF="../elks/path.html#f_components">components</A>.<A HREF="../elks/arrayed_list.html#f_count">count</A> = <A HREF="../elks/path.html#f_components">components</A>.<A HREF="../elks/arrayed_list.html#f_count">count</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_same_as"><A HREF="../elks/path.html#f_same_as">same_as</A> (other: <B>detachable</B> <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is Current the same path as </FONT><I>other</I><FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Note that no canonicalization is being performed to compare paths,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> paths are compared using the OS-specific convention for letter case.</FONT>
        <B>do</B>
            <B>if</B> other = <B>Void</B> <B>then</B>
            <B>elseif</B> other = <B>Current</B> <B>then</B>
                <B>Result</B> := <B>True</B>
            <B>else</B>
                <B>if</B> {<A HREF="../elks/operating_environment.html">OPERATING_ENVIRONMENT</A>}.<A HREF="../elks/operating_environment.html#f_case_sensitive_path_names">case_sensitive_path_names</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/path.html#f_is_case_sensitive_equal">is_case_sensitive_equal</A> (other)
                <B>else</B>
                    <B>Result</B> := <A HREF="../elks/path.html#f_is_case_insensitive_equal">is_case_insensitive_equal</A> (other)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_less"><A HREF="../elks/path.html#f_is_less">is_less</A> <B>alias</B> "&lt;" (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current object less than </FONT><I>other</I><FONT COLOR="red">?</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/operating_environment.html">OPERATING_ENVIRONMENT</A>}.<A HREF="../elks/operating_environment.html#f_case_sensitive_path_names">case_sensitive_path_names</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A> &lt; other.<A HREF="../elks/path.html#f_storage">storage</A>
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/immutable_string_32.html#f_as_lower">as_lower</A> &lt; other.<A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/immutable_string_32.html#f_as_lower">as_lower</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_equal"><A HREF="../elks/path.html#f_is_equal">is_equal</A> (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>other</I><FONT COLOR="red"> attached to an object considered</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> equal to current object?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/path.html#f_same_as">same_as</A> (other)
        <B>end</B></A>

    <A NAME="f_is_case_sensitive_equal"><A HREF="../elks/path.html#f_is_case_sensitive_equal">is_case_sensitive_equal</A> (other: <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Compare path and paying attention to case.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>if</B> other = <B>Current</B> <B>then</B>
                <B>Result</B> := <B>True</B>
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_is_equal">is_equal</A> (other.<A HREF="../elks/path.html#f_storage">storage</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_case_insensitive_equal"><A HREF="../elks/path.html#f_is_case_insensitive_equal">is_case_insensitive_equal</A> (other: <A HREF="../elks/path.html">PATH</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Compare path without paying attention to case. If the path is containing some mixed-encoding</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> we might ignore many characters when doing the case comparison.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>if</B> other = <B>Current</B> <B>then</B>
                <B>Result</B> := <B>True</B>
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_name">name</A>.<A HREF="../elks/readable_string_32.html#f_is_case_insensitive_equal">is_case_insensitive_equal</A> (other.<A HREF="../elks/path.html#f_name">name</A>)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_copy"><A HREF="../elks/path.html#f_copy">copy</A> (other: <B>like</B> <B>Current</B>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Update current object using fields of object attached</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to </FONT><I>other</I><FONT COLOR="red">, so as to yield equal objects.</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Current</B> <B>then</B>
                <A HREF="../elks/any.html#f_standard_copy">standard_copy</A> (other)
                <A HREF="../elks/path.html#f_storage">storage</A> := other.<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/any.html#f_twin">twin</A>
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Output</FONT>

    <A NAME="f_out"><A HREF="../elks/path.html#f_out">out</A>: <A HREF="../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Unicode representation of the underlying filename if representable,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> otherwise a UTF-8 encoded version.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_utf_8_name">utf_8_name</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to have a printable representation whose format is not going</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to be changed in the future.</FONT>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/readable_string_8.html">READABLE_STRING_8</A>} <A HREF="../elks/path.html#f_name">name</A> <B>as</B> n <B>then</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_8.html#f_make_from_string">make_from_string</A> (n)
            <B>else</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_utf_8_name">utf_8_name</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_utf_8_name"><A HREF="../elks/path.html#f_utf_8_name">utf_8_name</A>: <A HREF="../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> UTF-8 representation of the underlying filename.</FONT>
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>Result</B> := u.<A HREF="../elks/utf_converter.html#f_escaped_utf_32_string_to_utf_8_string_8">escaped_utf_32_string_to_utf_8_string_8</A> (<A HREF="../elks/path.html#f_name">name</A>)
        <B>end</B></A>

    <A NAME="f_name"><A HREF="../elks/path.html#f_name">name</A>: <A HREF="../elks/immutable_string_32.html">IMMUTABLE_STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If current is representable in Unicode, the Unicode representation.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Otherwise all non-valid sequences for the current platform in the path are escaped</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> as mentioned in the note clause of the class.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To ensure roundtrip, you cannot use </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_name">name</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> directly to create a </FONT><I>FILE</I><FONT COLOR="red">, you have to</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> create a </FONT><I>PATH</I><FONT COLOR="red"> instance using </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_make_from_string">make_from_string</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> before passing it to the creation</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> procedure of </FONT><I>FILE</I><FONT COLOR="red"> taking an instance of </FONT><I>PATH</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> <B>attached</B> <A HREF="../elks/path.html#f_internal_name">internal_name</A> <B>as</B> l_name <B>then</B>
                <B>Result</B> := l_name
            <B>else</B>
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_32.html#f_make_from_string">make_from_string</A> (u.<A HREF="../elks/utf_converter.html#f_utf_16le_string_8_to_escaped_string_32">utf_16le_string_8_to_escaped_string_32</A> (<A HREF="../elks/path.html#f_storage">storage</A>))
                <B>else</B>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_32.html#f_make_from_string">make_from_string</A> (u.<A HREF="../elks/utf_converter.html#f_utf_8_string_8_to_escaped_string_32">utf_8_string_8_to_escaped_string_32</A> (<A HREF="../elks/path.html#f_storage">storage</A>))
                <B>end</B>
                <A HREF="../elks/path.html#f_internal_name">internal_name</A> := <B>Result</B>
            <B>end</B>
        <B>ensure</B>
            roundtrip: <A HREF="../elks/path.html#f_same_as">same_as</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_string">make_from_string</A> (<B>Result</B>) <B>end</B>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Output</FONT>

    <A NAME="f_debug_output"><A HREF="../elks/path.html#f_debug_output">debug_output</A>: <A HREF="../elks/readable_string_32.html">READABLE_STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> String that should be displayed in debugger to represent </FONT><I>Current</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/path.html#f_name">name</A>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/native_string_handler.html">NATIVE_STRING_HANDLER</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_to_pointer"><A HREF="../elks/path.html#f_to_pointer">to_pointer</A>: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Platform specific representation of Current.</FONT>
        <B>local</B>
            l_cstr: <A HREF="../elks/c_string.html">C_STRING</A>
        <B>do</B>
            <B>create</B> l_cstr.<A HREF="../elks/c_string.html#f_make_empty">make_empty</A> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> + <A HREF="../elks/path.html#f_unit_size">unit_size</A> - 1);
            l_cstr.<A HREF="../elks/c_string.html#f_set_string">set_string</A> (<A HREF="../elks/path.html#f_storage">storage</A>)
            <B>Result</B> := l_cstr.<A HREF="../elks/c_string.html#f_managed_data">managed_data</A>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/path.html">PATH</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_is_normalized"><A HREF="../elks/path.html#f_is_normalized">is_normalized</A>: <A HREF="../elks/boolean.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Has current string be normalized?</FONT>

    <A NAME="f_storage"><A HREF="../elks/path.html#f_storage">storage</A>: <A HREF="../elks/string_8.html">STRING_8</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Internal storage for Current.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> On UNIX, it is a binary sequence encoded in UTF-8 by default.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> On Windows, it is a binary sequence encoded in UTF-16LE by default.</FONT>

    <A NAME="f_unit_size"><A HREF="../elks/path.html#f_unit_size">unit_size</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Size in bytes of a unit for </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_storage">storage</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := 2
            <B>else</B>
                <B>Result</B> := 1
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_reset_internal_data"><A HREF="../elks/path.html#f_reset_internal_data">reset_internal_data</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reset the private cache data.</FONT>
        <B>do</B>
            <A HREF="../elks/path.html#f_internal_name">internal_name</A> := <B>Void</B>
        <B>end</B></A>

    <A NAME="f_normalize"><A HREF="../elks/path.html#f_normalize">normalize</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Normalize current with respect to directory separators:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 1 - On Windows, replace all </FONT><I>/</I><FONT COLOR="red"> by </FONT><I>\</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 2 - Remove trailing directory separator unless this is a root for which</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">     we will keep just one. This is the case of:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">      * C:\</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">      * \\server\share\</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">      * \\?\C:\</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">      * /</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">     where removing the trailing directory separator would transform</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">     current path from being absolute to be relative.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 3 - Remove redundant directory separator in a path except on Windows for</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">     the starting \\ in a UNC path. (i.e. /foo////bar -&gt; /foo/bar, and</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">     \\server\share\\\\foo\\\bar -&gt; \\server\share\foo\bar.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 4 - If a path is just made of directory separator, it become that directory separator.</FONT>
        <B>require</B>
            not_normalized: <B>not</B> <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
            storage_not_empty: <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt;= <A HREF="../elks/path.html#f_unit_size">unit_size</A>
        <B>local</B>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
            i, j, nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_root_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_in_separator, l_copy_character, l_has_unc: <A HREF="../elks/boolean.html">BOOLEAN</A>
        <B>do</B>
            l_storage := <A HREF="../elks/path.html#f_storage">storage</A>
            nb := l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                i := 1
                <B>if</B> nb &gt;= <A HREF="../elks/path.html#f_min_unc_path_count">Min_unc_path_count</A> <B>then</B>
                    <B>if</B> (<A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 1, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>) <B>and</B> (<A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 3, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>) <B>or</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 3, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>))) <B>or</B> (<A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 1, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>and</B> (<A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 3, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>or</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 3, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>))) <B>then</B>
                        <B>if</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 5, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, 5, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>then</B>
                            i := 5
                            l_has_unc := <B>True</B>
                        <B>end</B>
                    <B>end</B>
                <B>end</B>
                <B>from</B>
                    j := i
                    l_copy_character := <B>True</B>
                <B>until</B>
                    i &gt; nb
                <B>loop</B>
                    <B>if</B> l_in_separator <B>then</B>
                        l_copy_character := <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>)
                        l_in_separator := <B>not</B> l_copy_character
                    <B>else</B>
                        <B>if</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>) <B>then</B>
                            l_storage.<A HREF="../elks/string_8.html#f_put">put</A> (<A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>, i)
                            l_in_separator := <B>True</B>
                        <B>else</B>
                            l_in_separator := <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>)
                        <B>end</B>
                    <B>end</B>
                    <B>if</B> l_copy_character <B>then</B>
                        <B>if</B> i /= j <B>then</B>
                            l_storage.<A HREF="../elks/string_8.html#f_put">put</A> (l_storage.<A HREF="../elks/string_8.html#f_item">item</A> (i), j);
                            l_storage.<A HREF="../elks/string_8.html#f_put">put</A> (l_storage.<A HREF="../elks/string_8.html#f_item">item</A> (i + 1), j + 1)
                        <B>end</B>
                        j := j + 2
                    <B>end</B>
                    i := i + 2
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    i := 1
                    j := i
                    l_copy_character := <B>True</B>
                <B>until</B>
                    i &gt; nb
                <B>loop</B>
                    <B>if</B> l_in_separator <B>then</B>
                        l_copy_character := <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>)
                        l_in_separator := <B>not</B> l_copy_character
                    <B>else</B>
                        l_in_separator := <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, i, <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>)
                    <B>end</B>
                    <B>if</B> l_copy_character <B>then</B>
                        <B>if</B> i /= j <B>then</B>
                            l_storage.<A HREF="../elks/string_8.html#f_put">put</A> (l_storage.<A HREF="../elks/string_8.html#f_item">item</A> (i), j)
                        <B>end</B>
                        j := j + 1
                    <B>end</B>
                    i := i + 1
                <B>end</B>
            <B>end</B>
            <B>if</B> i /= j <B>then</B>
                l_storage.<A HREF="../elks/string_8.html#f_keep_head">keep_head</A> (j - 1)
            <B>end</B>
            <A HREF="../elks/path.html#f_is_normalized">is_normalized</A> := <B>True</B>
            <B>if</B> l_has_unc <B>then</B>
                l_root_pos := <A HREF="../elks/path.html#f_root_end_position">root_end_position</A>
                <B>if</B> l_root_pos = 0 <B>then</B>
                    l_storage.<A HREF="../elks/string_8.html#f_remove_head">remove_head</A> (<A HREF="../elks/path.html#f_unit_size">unit_size</A>)
                <B>end</B>
            <B>end</B>
            <B>if</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>) <B>and then</B> <A HREF="../elks/path.html#f_root_end_position">root_end_position</A> &lt; l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                l_storage.<A HREF="../elks/string_8.html#f_remove_tail">remove_tail</A> (<A HREF="../elks/path.html#f_unit_size">unit_size</A>)
            <B>end</B>
        <B>ensure</B>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_internal_name"><A HREF="../elks/path.html#f_internal_name">internal_name</A>: <B>detachable</B> <A HREF="../elks/immutable_string_32.html">IMMUTABLE_STRING_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cache for </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_name">name</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>

    <A NAME="f_platform"><A HREF="../elks/path.html#f_platform">Platform</A>: <A HREF="../elks/platform.html">PLATFORM</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access underlying platform info, used to satisfy invariant below.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_env"><A HREF="../elks/path.html#f_env">Env</A>: <A HREF="../elks/execution_environment.html">EXECUTION_ENVIRONMENT</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access to underlying execution environment.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>
        <B>end</B></A>

    <A NAME="f_root_end_position"><A HREF="../elks/path.html#f_root_end_position">root_end_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of the last character of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_root">root</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> as a full unit if any, 0 otherwise.</FONT>
        <B>require</B>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>local</B>
            l_drive_letter: <A HREF="../elks/character_8.html">CHARACTER_8</A>
            l_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <B>not</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> = <A HREF="../elks/path.html#f_unit_size">unit_size</A> <B>and then</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 1, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>then</B>
                        <B>Result</B> := <A HREF="../elks/path.html#f_unit_size">unit_size</A>
                    <B>elseif</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt;= 4 <B>and then</B> (<A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (2) = '%U' <B>and</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (4) = '%U') <B>then</B>
                        l_drive_letter := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (1).<A HREF="../elks/character_8_ref.html#f_as_lower">as_lower</A>
                        <B>if</B> l_drive_letter &gt;= 'a' <B>and</B> l_drive_letter &lt;= 'z' <B>and</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (3) = ':' <B>then</B>
                            <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt;= 3 * <A HREF="../elks/path.html#f_unit_size">unit_size</A> <B>and then</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, 5, <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>) <B>then</B>
                                <B>Result</B> := 6
                            <B>else</B>
                                <B>Result</B> := 4
                            <B>end</B>
                        <B>elseif</B> l_drive_letter = <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A> <B>and</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (3) /= <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A> <B>then</B>
                            <B>Result</B> := <A HREF="../elks/path.html#f_unit_size">unit_size</A>
                        <B>elseif</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> &gt;= <A HREF="../elks/path.html#f_min_unc_path_count">Min_unc_path_count</A> <B>and</B> l_drive_letter = <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A> <B>and</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (3) = <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A> <B>and</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (5) /= <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A> <B>then</B>
                            l_pos := <A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (7)
                            <B>if</B> l_pos &gt; 0 <B>and</B> l_pos + <A HREF="../elks/path.html#f_unit_size">unit_size</A> &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> <B>then</B>
                                l_pos := <A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (l_pos + <A HREF="../elks/path.html#f_unit_size">unit_size</A>)
                                <B>if</B> l_pos &gt; 0 <B>then</B>
                                    <B>Result</B> := l_pos + 1
                                <B>else</B>
                                    <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>
                                <B>end</B>
                            <B>end</B>
                        <B>end</B>
                    <B>end</B>
                <B>else</B>
                    <B>if</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/string_8.html#f_item">item</A> (1) = <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A> <B>then</B>
                        <B>Result</B> := 1
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            non_negative: <B>Result</B> &gt;= 0
            not_too_big: <B>Result</B> &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            valid_for_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <B>Result</B> \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A> = 0
        <B>end</B></A>

    <A NAME="f_end_position_of_last_directory_separator"><A HREF="../elks/path.html#f_end_position_of_last_directory_separator">end_position_of_last_directory_separator</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position of the last directory separator in Current, not including the trailing ones if any, 0 if none.</FONT>
        <B>require</B>
            is_normalized: <A HREF="../elks/path.html#f_is_normalized">is_normalized</A>
        <B>do</B>
            <B>if</B> <B>not</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1
                <B>if</B> <B>Result</B> &gt;= 1 <B>then</B>
                    <B>from</B>
                    <B>until</B>
                        <B>Result</B> &lt; 1 <B>or</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, <B>Result</B>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
                    <B>loop</B>
                        <B>Result</B> := <B>Result</B> - <A HREF="../elks/path.html#f_unit_size">unit_size</A>
                    <B>end</B>
                <B>end</B>
                <B>if</B> <B>Result</B> &lt; 0 <B>then</B>
                    <B>Result</B> := 0
                <B>else</B>
                    <B>Result</B> := <B>Result</B> + <A HREF="../elks/path.html#f_unit_size">unit_size</A> - 1
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            non_negative: <B>Result</B> &gt;= 0
            not_too_big: <B>Result</B> &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            valid_for_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <B>Result</B> \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A> = 0
        <B>end</B></A>

    <A NAME="f_next_directory_separator"><A HREF="../elks/path.html#f_next_directory_separator">next_directory_separator</A> (a_starting_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Starting at a position </FONT><I>a_starting_pos</I><FONT COLOR="red"> find the position in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_storage">storage</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> of the</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> next directory separator, or 0 otherwise.</FONT>
        <B>require</B>
            a_starting_pos_valid: a_starting_pos &gt;= 1 <B>and</B> a_starting_pos &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            a_starting_pos_is_well_positionned: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> a_starting_pos \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A> = 1
        <B>local</B>
            nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_step: <B>like</B> <A HREF="../elks/path.html#f_unit_size">unit_size</A>
            l_sep: <B>like</B> <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>
            l_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>
        <B>do</B>
            <B>from</B>
                l_step := <A HREF="../elks/path.html#f_unit_size">unit_size</A>
                l_sep := <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>
                <B>Result</B> := a_starting_pos
                l_storage := <A HREF="../elks/path.html#f_storage">storage</A>
                nb := l_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            <B>until</B>
                <B>Result</B> &lt; 1 <B>or</B> <B>Result</B> &gt; nb <B>or</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (l_storage, <B>Result</B>, l_sep)
            <B>loop</B>
                <B>Result</B> := <B>Result</B> + l_step
            <B>end</B>
            <B>if</B> <B>Result</B> &gt; nb <B>then</B>
                <B>Result</B> := 0
            <B>end</B>
        <B>ensure</B>
            valid_position: <B>Result</B> &gt;= 0 <B>and</B> <B>Result</B> &lt;= <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A>
            well_positionned: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> ((<B>Result</B> = 0) <B>or</B> (<B>Result</B> \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A> = 1))
            has_separator: <B>Result</B> &gt; 0 <B>implies</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (<A HREF="../elks/path.html#f_storage">storage</A>, <B>Result</B>, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
        <B>end</B></A>

    <A NAME="f_internal_append_into"><A HREF="../elks/path.html#f_internal_append_into">internal_append_into</A> (a_storage: <A HREF="../elks/string_8.html">STRING_8</A>; other: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>; a_separator: <A HREF="../elks/character_8.html">CHARACTER_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Append </FONT><I>a_separator</I><FONT COLOR="red"> if different from '%U' and not already present as last character</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in </FONT><I>a_storage</I><FONT COLOR="red">, and then </FONT><I>other</I><FONT COLOR="red"> to Current.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
            other_not_empty: <B>not</B> other.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A>
        <B>local</B>
            u: <A HREF="../elks/utf_converter.html">UTF_CONVERTER</A>
        <B>do</B>
            <B>if</B> <B>not</B> other.<A HREF="../elks/readable_string_general.html#f_is_empty">is_empty</A> <B>then</B>
                <B>if</B> a_separator /= '%U' <B>and</B> <B>not</B> a_storage.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>and then</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (a_storage, a_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, a_separator) <B>and</B> other.<A HREF="../elks/readable_string_general.html#f_item">item</A> (1) /= <A HREF="../elks/path.html#f_unix_separator">Unix_separator</A>.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A> <B>then</B>
                    <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                        <B>if</B> other.<A HREF="../elks/readable_string_general.html#f_item">item</A> (1) /= <A HREF="../elks/path.html#f_windows_separator">Windows_separator</A>.<A HREF="../elks/character_8.html#f_to_character_32">to_character_32</A> <B>then</B>
                            a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> (a_separator);
                            a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> ('%U')
                        <B>end</B>
                    <B>else</B>
                        a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> (a_separator)
                    <B>end</B>
                <B>end</B>
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    u.<A HREF="../elks/utf_converter.html#f_escaped_utf_32_string_into_utf_16le_string_8">escaped_utf_32_string_into_utf_16le_string_8</A> (other, a_storage)
                <B>else</B>
                    u.<A HREF="../elks/utf_converter.html#f_escaped_utf_32_string_into_utf_8_string_8">escaped_utf_32_string_into_utf_8_string_8</A> (other, a_storage)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_internal_path_append_into"><A HREF="../elks/path.html#f_internal_path_append_into">internal_path_append_into</A> (a_storage, other: <A HREF="../elks/string_8.html">STRING_8</A>; a_separator: <A HREF="../elks/character_8.html">CHARACTER_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Append </FONT><I>a_separator</I><FONT COLOR="red"> if other than '%U' and not already present as last character</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of </FONT><I>a_storage</I><FONT COLOR="red">, and then </FONT><I>other</I><FONT COLOR="red"> to </FONT><I>a_storage</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
            other_not_empty: <B>not</B> other.<A HREF="../elks/finite.html#f_is_empty">is_empty</A>
        <B>do</B>
            <B>if</B> a_separator /= '%U' <B>and</B> <B>not</B> a_storage.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>and then</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (a_storage, a_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, a_separator) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (other, 1, a_separator) <B>then</B>
                a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> (a_separator)
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> ('%U')
                <B>end</B>
            <B>end</B>;
            a_storage.<A HREF="../elks/string_8.html#f_append">append</A> (other)
        <B>end</B></A>

    <A NAME="f_internal_path_append_substring_into"><A HREF="../elks/path.html#f_internal_path_append_substring_into">internal_path_append_substring_into</A> (a_storage, other: <A HREF="../elks/string_8.html">STRING_8</A>; other_start_index, other_end_index: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_separator: <A HREF="../elks/character_8.html">CHARACTER_8</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Append </FONT><I>a_separator</I><FONT COLOR="red"> if other than '%U' and not already present as last character</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of </FONT><I>a_storage.substring (other_start_index, other_end_index)</I><FONT COLOR="red">, and then </FONT><I>other</I><FONT COLOR="red"> to </FONT><I>a_storage</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
            other_not_empty: <B>not</B> other.<A HREF="../elks/finite.html#f_is_empty">is_empty</A>
            other_has_not_trailing_directory_separator: <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (other, other.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, <A HREF="../elks/path.html#f_directory_separator">directory_separator</A>)
        <B>do</B>
            <B>if</B> a_separator /= '%U' <B>and</B> <B>not</B> a_storage.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>and then</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (a_storage, a_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> - <A HREF="../elks/path.html#f_unit_size">unit_size</A> + 1, a_separator) <B>and</B> <B>not</B> <A HREF="../elks/path.html#f_is_character">is_character</A> (other, other_start_index, a_separator) <B>then</B>
                a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> (a_separator)
                <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                    a_storage.<A HREF="../elks/string_8.html#f_append_character">append_character</A> ('%U')
                <B>end</B>
            <B>end</B>;
            a_storage.<A HREF="../elks/string_8.html#f_append_substring">append_substring</A> (other, other_start_index, other_end_index)
        <B>end</B></A>

    <A NAME="f_is_character"><A HREF="../elks/path.html#f_is_character">is_character</A> (a_storage: <B>like</B> <A HREF="../elks/path.html#f_storage">storage</A>; a_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_char: <A HREF="../elks/character_8.html">CHARACTER_8</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>a_char</I><FONT COLOR="red"> appearing at position </FONT><I>a_pos</I><FONT COLOR="red"> (in bytes) in </FONT><I>a_storage</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_pos_valid: a_storage.<A HREF="../elks/readable_string_general.html#f_valid_index">valid_index</A> (a_pos)
            a_pos_valid_for_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> a_storage.<A HREF="../elks/readable_string_general.html#f_valid_index">valid_index</A> (a_pos + 1)
            a_pos_odd_for_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> (a_pos \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A>) = 1
            a_storage_count_valid_for_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> (a_storage.<A HREF="../elks/readable_string_8.html#f_count">count</A> \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A>) = 0
        <B>do</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := a_storage.<A HREF="../elks/string_8.html#f_item">item</A> (a_pos) = a_char <B>and then</B> a_storage.<A HREF="../elks/string_8.html#f_item">item</A> (a_pos + 1) = '%U'
            <B>else</B>
                <B>Result</B> := a_storage.<A HREF="../elks/string_8.html#f_item">item</A> (a_pos) = a_char
            <B>end</B>
        <B>ensure</B>
            definition: <B>Result</B> = ((a_storage.<A HREF="../elks/string_8.html#f_item">item</A> (a_pos) = a_char) <B>and then</B> ({<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> a_storage.<A HREF="../elks/string_8.html#f_item">item</A> (a_pos + 1) = '%U'))
        <B>end</B></A>

    <A NAME="f_directory_separator_string"><A HREF="../elks/path.html#f_directory_separator_string">Directory_separator_string</A>: <A HREF="../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default directory separator for the current platform.</FONT>
        <B>once</B>
            <B>if</B> {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>then</B>
                <B>Result</B> := {<A HREF="../elks/string_32.html">STRING_32</A>} "\"
            <B>else</B>
                <B>Result</B> := {<A HREF="../elks/string_32.html">STRING_32</A>} "/"
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_min_unc_path_count"><A HREF="../elks/path.html#f_min_unc_path_count">Min_unc_path_count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 10</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of characters in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/path.html#f_storage">storage</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to make up a valid UNC path: \\a\c whic is 5 Unicode characters, thus 10 bytes.</FONT>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Externals</FONT>

    <A NAME="f_c_same_files"><A HREF="../elks/path.html#f_c_same_files">c_same_files</A> (a_path1, a_path2: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Do C paths </FONT><I>a_path1</I><FONT COLOR="red"> and </FONT><I>a_path2</I><FONT COLOR="red"> represent the same file?</FONT>
        <B>require</B>
            a_path1_not_null: a_path1 /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            a_path2_not_null: a_path2 /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
        <B>external</B>
            "C inline use %"eif_eiffel.h%""
        <B>alias</B>
            "[
                EIF_BOOLEAN Result = EIF_FALSE;
                #ifdef EIF_WINDOWS
                		/* To check this, we use `CreateFileW' to open both file, and then using the information
                		 * returned by `GetFileInformationByHandle' we can check whether or not they are indeed
                		 * the same.
                		 * Note: it is important to use the W version of CreateFileW because arguments
                		 * are Unicode, not ASCII. */
                	BY_HANDLE_FILE_INFORMATION l_path1_info, l_path2_info;
                	HANDLE l_path2_file = CreateFileW ((LPCWSTR) $a_path2, GENERIC_READ, FILE_SHARE_READ, NULL,
                		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                	HANDLE l_path1_file = CreateFileW ((LPCWSTR) $a_path1, GENERIC_READ, FILE_SHARE_READ, NULL,
                			OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                
                	if ((l_path2_file == INVALID_HANDLE_VALUE) || (l_path1_file == INVALID_HANDLE_VALUE)) {
                			/* We do not need the handles anymore, simply close them. Since Microsoft
                			 * API accepts INVALID_HANDLE_VALUE we don't check the validity of arguments. */
                		CloseHandle(l_path2_file);
                		CloseHandle(l_path1_file);
                	} else {
                		BOOL success = GetFileInformationByHandle (l_path2_file, &#38;l_path2_info);
                		success = success &#38;&#38; GetFileInformationByHandle (l_path1_file, &#38;l_path1_info);
                			/* We do not need the handles anymore, simply close them. */
                		CloseHandle(l_path2_file);
                		CloseHandle(l_path1_file);
                		if (success) {
                				/* Check that `path2' and `path1' do not represent the same file. */
                			if
                				((l_path2_info.dwVolumeSerialNumber == l_path1_info.dwVolumeSerialNumber) &#38;&#38;
                				(l_path2_info.nFileIndexLow == l_path1_info.nFileIndexLow) &#38;&#38;
                				(l_path2_info.nFileIndexHigh == l_path1_info.nFileIndexHigh))
                			{
                				Result = EIF_TRUE;
                			}
                		}
                	}
                #else
                	struct stat buf1, buf2;
                	int status;
                	#ifdef HAS_LSTAT
                		status = lstat($a_path1, &#38;buf1);
                		if (status == 0) {
                				/* We found a file, now let's check if it is not a symbolic link. If it is, we use `stat'
                			 	 * to ensure the validity of the link. */
                			if ((buf1.st_mode &#38; S_IFLNK) == S_IFLNK) {
                				status = stat ($a_path1, &#38;buf1);
                			}
                		}
                		
                		if (status == 0) {
                			status = lstat($a_path2, &#38;buf2);
                			if (status == 0) {
                					/* We found a file, now let's check if it is not a symbolic link. If it is, we use `stat'
                				 	 * to ensure the validity of the link. */
                				if ((buf2.st_mode &#38; S_IFLNK) == S_IFLNK) {
                					status = stat ($a_path2, &#38;buf2);
                				}
                			}
                		}
                	#else
                		status = stat ($a_path1, &#38;buf1);
                		if (status == 0) {
                			status = stat ($a_path2, &#38;buf2);
                		}
                	#endif
                	if (status == 0) {
                			/* Both files are present, check they represent the same one. */
                		if ((buf1.st_dev == buf2.st_dev) &#38;&#38; (buf1.st_ino == buf2.st_ino)) {
                			Result = EIF_TRUE;
                		}
                	}
                #endif
                return Result;
            ]"
        <B>end</B></A>
    
<B>invariant</B>
    little_endian_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/path.html#f_platform">Platform</A>.<A HREF="../elks/platform.html#f_is_little_endian">Is_little_endian</A>
    even_count_on_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_8.html#f_count">count</A> \\ <A HREF="../elks/path.html#f_unit_size">unit_size</A> = 0
    no_forward_slash_on_windows: {<A HREF="../elks/platform.html">PLATFORM</A>}.<A HREF="../elks/platform.html#f_is_windows">is_windows</A> <B>implies</B> <B>not</B> <A HREF="../elks/path.html#f_storage">storage</A>.<A HREF="../elks/readable_string_general.html#f_has_substring">has_substring</A> ("/%U")

<B>note</B>
    copyright: "Copyright (c) 1984-2021, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/path.html">PATH</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="path_chart.html">Chart</A></TD><TD><A HREF="path_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

