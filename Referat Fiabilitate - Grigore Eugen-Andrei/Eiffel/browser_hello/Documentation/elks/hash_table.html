<HTML><HEAD>
<meta name="description" content="Hash tables, used to store items identified by hashable keys"/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="instructions" content="See instructions at the end of the class."/>
<meta name="warning" content="Modifying an object used as a key by an item present in a table will cause incorrect behavior. If you will be modifying key objects, pass a clone, not the object itself, as key argument to `put' and `replace_key'."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="instruction" content="TTSeveral procedures are provided for inserting an item TTwith a given key.  TTHere is how to choose between them:  TTT- Use `put' if you want to do an insertion only if TTT  there was no item with the given key, doing nothing TTT  otherwise. (You can find out on return if there was one, TTT  and what it was.)  TTT- Use `force' if you always want to insert the item; TTT  if there was one for the given key it will be removed, TTT  (and you can find out on return what it was).  TTT- Use `extend' if you are sure there is no item with TTT  the given key, enabling faster insertion (but TTT  unpredictable behavior if this assumption is not true).  TTT- Use `replace' if you want to replace an already present TTT  item with the given key, and do nothing if there is none.  TTIn addition you can use `replace_key' to change the key of an TTalready present item, identified by its previous key, or TTdo nothing if there is nothing for that previous key. TTYou can find out on return.  TTTo find out whether a key appears in the table, use `has'. TTTo find out the item, if any, associated with a certain key, TTuse `item'.  TTBoth of these routines perform a search. If you need TTboth pieces of information (does a key appear? And, if so, TTwhat is the associated item?), you can avoid performing TTtwo redundant traversals by using instead the combination TTof `search', `found' and `found_item' as follows:  TTTyour_table.search (your_key) TTTif your_table.found then TTTTwhat_you_where_looking_for := your_table.found_item TTTT... Do whatever is needed to `what_you_were_looking_for' ... TTTelse TTTT... No item was present for `your_key' ... TTTend"/>
<meta name="copyright" content="Copyright (c) 1984-2021, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>hash_table Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="hash_table_chart.html">Chart</A></TD><TD><A HREF="hash_table_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "Hash tables, used to store items identified by hashable keys"
    library: "Free implementation of ELKS library"
    instructions: "See instructions at the end of the class."
    warning: "[
        Modifying an object used as a key by an item present in a table will
        cause incorrect behavior. If you will be modifying key objects,
        pass a clone, not the object itself, as key argument to
        `<A HREF="../elks/hash_table.html#f_put">put</A>` and `<A HREF="../elks/hash_table.html#f_replace_key">replace_key</A>`.
    ]"

<B>class</B> 
    <A HREF="../elks/hash_table.html">HASH_TABLE</A> [G -&gt; , K -&gt; <B>detachable</B> <A HREF="../elks/hashable.html">HASHABLE</A>]

<B>inherit</B>
    <A HREF="../elks/unbounded.html">UNBOUNDED</A> [G]
        <B>rename</B>
            <A HREF="../elks/container.html#f_has">has</A> <B>as</B> <A HREF="../elks/hash_table.html#f_has_item">has_item</A>
        <B>redefine</B>
            <A HREF="../elks/hash_table.html#f_copy">copy</A>,
            <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A>
        <B>end</B>

    <A HREF="../elks/dynamic_table.html">DYNAMIC_TABLE</A> [G, K]
        <B>rename</B>
            <A HREF="../elks/table.html#f_at">at</A> <B>as</B> <A HREF="../elks/hash_table.html#f_definite_item">definite_item</A>,
            <A HREF="../elks/bag.html#f_extend">extend</A> <B>as</B> <A HREF="../elks/hash_table.html#f_collection_extend">collection_extend</A>,
            <A HREF="../elks/table.html#f_item">item</A> <B>as</B> <A HREF="../elks/hash_table.html#f_definite_item">definite_item</A>,
            <A HREF="../elks/container.html#f_has">has</A> <B>as</B> <A HREF="../elks/hash_table.html#f_has_item">has_item</A>,
            <A HREF="../elks/table.html#f_valid_key">valid_key</A> <B>as</B> <A HREF="../elks/hash_table.html#f_has">has</A>
        <B>redefine</B>
            <A HREF="../elks/hash_table.html#f_copy">copy</A>,
            <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A>
        <B>end</B>

    <A HREF="../elks/table_iterable.html">TABLE_ITERABLE</A> [G, K]
        <B>redefine</B>
            <A HREF="../elks/hash_table.html#f_copy">copy</A>,
            <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A>
        <B>end</B>

    <A HREF="../elks/readable_indexable.html">READABLE_INDEXABLE</A> [G]
        <B>rename</B>
            <A HREF="../elks/readable_indexable.html#f_item">item</A> <B>as</B> <A HREF="../elks/hash_table.html#f_iteration_item">iteration_item</A>,
            <A HREF="../elks/readable_indexable.html#f_lower">lower</A> <B>as</B> <A HREF="../elks/hash_table.html#f_iteration_lower">iteration_lower</A>,
            <A HREF="../elks/readable_indexable.html#f_upper">upper</A> <B>as</B> <A HREF="../elks/hash_table.html#f_iteration_upper">iteration_upper</A>,
            <A HREF="../elks/readable_indexable.html#f_valid_index">valid_index</A> <B>as</B> <A HREF="../elks/hash_table.html#f_valid_iteration_index">valid_iteration_index</A>
        <B>redefine</B>
            <A HREF="../elks/hash_table.html#f_copy">copy</A>,
            <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A>,
            <A HREF="../elks/hash_table.html#f_new_cursor">new_cursor</A>
        <B>end</B>

    <A HREF="../elks/mismatch_corrector.html">MISMATCH_CORRECTOR</A>
        <B>export</B>
            {NONE} <B>all</B>
            {<A HREF="../elks/any.html">ANY</A>} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>
        <B>undefine</B>
            <A HREF="../elks/hash_table.html#f_copy">copy</A>,
            <A HREF="../elks/hash_table.html#f_is_equal">is_equal</A>
        <B>redefine</B>
            <A HREF="../elks/hash_table.html#f_correct_mismatch">correct_mismatch</A>
        <B>end</B>

<B>create</B> 
    <A HREF="../elks/hash_table.html#f_make">make</A>,
    <A HREF="../elks/hash_table.html#f_make_equal">make_equal</A>,
    <A HREF="../elks/hash_table.html#f_make_from_iterable_tuples">make_from_iterable_tuples</A>

<B>convert</B>
    <A HREF="../elks/hash_table.html#f_make_from_iterable_tuples">make_from_iterable_tuples</A> ({<A HREF="../elks/array.html">ARRAY</A> [<A HREF="../elks/tuple.html">TUPLE</A> [G, K]]})

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_make"><A HREF="../elks/hash_table.html#f_make">make</A> (n: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Allocate hash table for at least </FONT><I>n</I><FONT COLOR="red"> items.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The table will be resized automatically</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if more than </FONT><I>n</I><FONT COLOR="red"> items are inserted.</FONT>
        <B>require</B>
            n_non_negative: n &gt;= 0
        <B>local</B>
            clever: <A HREF="../elks/primes.html">PRIMES</A>
            l_default_value: <B>detachable</B> G
            l_default_key: <B>detachable</B> K
            l_size: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> clever
            l_size := n.<A HREF="../elks/comparable.html#f_max">max</A> (<A HREF="../elks/hash_table.html#f_minimum_capacity">Minimum_capacity</A>)
            l_size := l_size + l_size // 2 + 1
            l_size := clever.<A HREF="../elks/primes.html#f_higher_prime">higher_prime</A> (l_size)
            <A HREF="../elks/hash_table.html#f_capacity">capacity</A> := l_size
            <B>create</B> <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_make_empty">make_empty</A> (n + 1)
            <B>create</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_make_empty">make_empty</A> (n + 1)
            <B>create</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_make_filled">make_filled</A> (<B>False</B>, n + 1)
            <B>create</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_make_filled">make_filled</A> (<A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>, l_size + 1)
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := n + 1
            <A HREF="../elks/hash_table.html#f_count">count</A> := 0
            <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <A HREF="../elks/hash_table.html#f_control">control</A> := 0
            <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>False</B>
            <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := 0
            <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table.html#f_ht_max_position">Ht_max_position</A>
            <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_value
            <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
        <B>ensure</B>
            breathing_space: n &lt; <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
            more_than_minimum: <A HREF="../elks/hash_table.html#f_capacity">capacity</A> &gt; <A HREF="../elks/hash_table.html#f_minimum_capacity">Minimum_capacity</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table.html#f_special_status">special_status</A>
        <B>end</B></A>

    <A NAME="f_make_equal"><A HREF="../elks/hash_table.html#f_make_equal">make_equal</A> (n: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Allocate hash table for at least </FONT><I>n</I><FONT COLOR="red"> items.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The table will be resized automatically</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if more than </FONT><I>n</I><FONT COLOR="red"> items are inserted.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><I>~</I><FONT COLOR="red"> to compare items.</FONT>
        <B>require</B>
            n_non_negative: n &gt;= 0
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_make">make</A> (n)
            <A HREF="../elks/container.html#f_compare_objects">compare_objects</A>
        <B>ensure</B>
            breathing_space: n &lt; <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
            more_than_minimum: <A HREF="../elks/hash_table.html#f_capacity">capacity</A> &gt; <A HREF="../elks/hash_table.html#f_minimum_capacity">Minimum_capacity</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table.html#f_special_status">special_status</A>
            compare_objects: <A HREF="../elks/container.html#f_object_comparison">object_comparison</A>
        <B>end</B></A>

    <A NAME="f_make_from_iterable_tuples"><A HREF="../elks/hash_table.html#f_make_from_iterable_tuples">make_from_iterable_tuples</A> (other: <A HREF="../elks/iterable.html">ITERABLE</A> [<A HREF="../elks/tuple.html">TUPLE</A> [G, K]])
        <B>local</B>
            t: <A HREF="../elks/tuple.html">TUPLE</A> [value: G; key: K]
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_make">make</A> (<B>if</B> <B>attached</B> {<A HREF="../elks/finite.html">FINITE</A> [<A HREF="../elks/tuple.html">TUPLE</A> [G, K]]} other <B>as</B> f <B>then</B>
                    f.<A HREF="../elks/finite.html#f_count">count</A>
                <B>elseif</B> <B>attached</B> {<A HREF="../elks/readable_indexable.html">READABLE_INDEXABLE</A> [<A HREF="../elks/tuple.html">TUPLE</A> [G, K]]} other <B>as</B> r <B>then</B>
                    r.<A HREF="../elks/readable_indexable.html#f_upper">upper</A> - r.<A HREF="../elks/readable_indexable.html#f_lower">lower</A> + 1
                <B>else</B>
                    0
                <B>end</B>)
            <B>across</B>
                other <B>as</B> o
            <B>loop</B>
                t := o
                <A HREF="../elks/hash_table.html#f_force">force</A> (t.value, t.key)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_accommodate"><A HREF="../elks/hash_table.html#f_accommodate">accommodate</A> (n: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reallocate table with enough space for </FONT><I>n</I><FONT COLOR="red"> items;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> keep all current items.</FONT>
        <B>require</B>
            n &gt;= 0
        <B>local</B>
            i, nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            new_table: <B>like</B> <B>Current</B>
            l_content: <B>like</B> <A HREF="../elks/hash_table.html#f_content">content</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>
        <B>do</B>
            <B>from</B>
                new_table := <A HREF="../elks/hash_table.html#f_empty_duplicate">empty_duplicate</A> (<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>.<A HREF="../elks/comparable.html#f_max">max</A> (n))
                l_content := <A HREF="../elks/hash_table.html#f_content">content</A>
                l_keys := <A HREF="../elks/hash_table.html#f_keys">keys</A>
                nb := l_keys.<A HREF="../elks/special.html#f_count">count</A>
            <B>until</B>
                i = nb
            <B>loop</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i) <B>then</B>
                    new_table.<A HREF="../elks/hash_table.html#f_put">put</A> (l_content.<A HREF="../elks/special.html#f_item">item</A> (i), l_keys.<A HREF="../elks/special.html#f_item">item</A> (i))
                <B>end</B>
                i := i + 1
            <B>end</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                i := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>);
                new_table.<A HREF="../elks/hash_table.html#f_put">put</A> (l_content.<A HREF="../elks/special.html#f_item">item</A> (i), <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (i))
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_set_content">set_content</A> (new_table.<A HREF="../elks/hash_table.html#f_content">content</A>)
            <A HREF="../elks/hash_table.html#f_set_keys">set_keys</A> (new_table.<A HREF="../elks/hash_table.html#f_keys">keys</A>)
            <A HREF="../elks/hash_table.html#f_set_deleted_marks">set_deleted_marks</A> (new_table.<A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>)
            <A HREF="../elks/hash_table.html#f_set_indexes_map">set_indexes_map</A> (new_table.<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>)
            <A HREF="../elks/hash_table.html#f_capacity">capacity</A> := new_table.<A HREF="../elks/hash_table.html#f_capacity">capacity</A>
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := new_table.<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
        <B>ensure</B>
            count_not_changed: <A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A>
            breathing_space: <A HREF="../elks/hash_table.html#f_count">count</A> &lt; <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_found_item"><A HREF="../elks/hash_table.html#f_found_item">found_item</A>: <B>detachable</B> G</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item, if any, yielded by last search operation</FONT>

    <A NAME="f_definite_item"><A HREF="../elks/hash_table.html#f_definite_item">definite_item</A> (key: K): G
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Entry of key </FONT><I>k</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            old_position: <B>like</B> <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
            old_control: <B>like</B> <A HREF="../elks/hash_table.html#f_control">control</A>
        <B>do</B>
            old_position := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
            old_control := <A HREF="../elks/hash_table.html#f_control">control</A>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
            <A HREF="../elks/hash_table.html#f_control">control</A> := old_control
            <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := old_position
        <B>end</B></A>

    <A NAME="f_item"><A HREF="../elks/hash_table.html#f_item">item</A> <B>alias</B> "[]" (key: K): <B>detachable</B> G <B>assign</B> <A HREF="../elks/hash_table.html#f_force">force</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item associated with </FONT><I>key</I><FONT COLOR="red">, if present</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> otherwise default value of type </FONT><I>G</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT>{<A HREF="../elks/hash_table.html">HASH_TABLE</A>}<FONT COLOR="red"> as synonym of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_at">at</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>note</B>
            option: stable
        <B>local</B>
            l_default_key: <B>detachable</B> K
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_key: K
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>))
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B>
            default_value_if_not_present: (<B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table.html#f_computed_default_value">computed_default_value</A>)
        <B>end</B></A>

    <A NAME="f_at"><A HREF="../elks/hash_table.html#f_at">at</A> <B>alias</B> "@" (key: K): <B>detachable</B> G <B>assign</B> <A HREF="../elks/hash_table.html#f_force">force</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Item associated with </FONT><I>key</I><FONT COLOR="red">, if present</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> otherwise default value of type </FONT><I>G</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT>{<A HREF="../elks/hash_table.html">HASH_TABLE</A>}<FONT COLOR="red"> as synonym of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_item">item</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>note</B>
            option: stable
        <B>local</B>
            l_default_key: <B>detachable</B> K
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_key: K
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>))
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B>
            default_value_if_not_present: (<B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table.html#f_computed_default_value">computed_default_value</A>)
        <B>end</B></A>

    <A NAME="f_has"><A HREF="../elks/hash_table.html#f_has">has</A> (key: K): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is there an item in the table with key </FONT><I>key</I><FONT COLOR="red">?</FONT>
        <B>local</B>
            l_default_key: <B>detachable</B> K
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_key: K
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                    <B>Result</B> := <B>True</B>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <B>Result</B> := <B>True</B>
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
            <B>end</B>
        <B>ensure then</B>
            default_case: (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)
        <B>end</B></A>

    <A NAME="f_has_key"><A HREF="../elks/hash_table.html#f_has_key">has_key</A> (key: K): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is there an item in the table with key </FONT><I>key</I><FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the found item.</FONT>
        <B>local</B>
            old_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_default_value: <B>detachable</B> G
        <B>do</B>
            old_position := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_found">found</A>
            <B>if</B> <B>Result</B> <B>then</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
            <B>else</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := old_position
        <B>ensure then</B>
            default_case: (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)
            found: <B>Result</B> = <A HREF="../elks/hash_table.html#f_found">found</A>
            item_if_found: <A HREF="../elks/hash_table.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table.html#f_item">item</A> (key))
        <B>end</B></A>

    <A NAME="f_has_item"><A HREF="../elks/hash_table.html#f_has_item">has_item</A> (v: G): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does structure include </FONT><I>v</I><FONT COLOR="red">?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (Reference or object equality, based on </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/container.html#f_object_comparison">object_comparison</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.)</FONT>
        <B>local</B>
            i, nb: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_content: <B>like</B> <A HREF="../elks/hash_table.html#f_content">content</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := v = <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>))
            <B>end</B>
            <B>if</B> <B>not</B> <B>Result</B> <B>then</B>
                l_content := <A HREF="../elks/hash_table.html#f_content">content</A>
                nb := l_content.<A HREF="../elks/special.html#f_count">count</A>
                <B>if</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>then</B>
                    <B>from</B>
                    <B>until</B>
                        i = nb <B>or else</B> <B>Result</B>
                    <B>loop</B>
                        <B>Result</B> := <A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i) <B>and then</B> (v ~ l_content.<A HREF="../elks/special.html#f_item">item</A> (i))
                        i := i + 1
                    <B>end</B>
                <B>else</B>
                    <B>from</B>
                    <B>until</B>
                        i = nb <B>or else</B> <B>Result</B>
                    <B>loop</B>
                        <B>Result</B> := <A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i) <B>and then</B> (v = l_content.<A HREF="../elks/special.html#f_item">item</A> (i))
                        i := i + 1
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_current_keys"><A HREF="../elks/hash_table.html#f_current_keys">current_keys</A>: <A HREF="../elks/array.html">ARRAY</A> [K]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> New array containing actually used keys, from 1 to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_count">count</A><FONT COLOR="red">`</FONT>
        <B>local</B>
            j: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            old_iteration_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>then</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/array.html#f_make_empty">make_empty</A>
            <B>else</B>
                old_iteration_position := <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
                <B>from</B>
                    <A HREF="../elks/hash_table.html#f_start">start</A>
                    <B>create</B> <B>Result</B>.<A HREF="../elks/array.html#f_make_filled">make_filled</A> (<A HREF="../elks/hash_table.html#f_key_for_iteration">key_for_iteration</A>, 1, <A HREF="../elks/hash_table.html#f_count">count</A>)
                    j := 1
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>until</B>
                    <A HREF="../elks/hash_table.html#f_off">off</A>
                <B>loop</B>
                    j := j + 1;
                    <B>Result</B>.<A HREF="../elks/array.html#f_put">put</A> (<A HREF="../elks/hash_table.html#f_key_for_iteration">key_for_iteration</A>, j)
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := old_iteration_position
            <B>end</B>
        <B>ensure</B>
            good_count: <B>Result</B>.<A HREF="../elks/array.html#f_count">count</A> = <A HREF="../elks/hash_table.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_item_for_iteration"><A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A>: G
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element at current iteration position</FONT>
        <B>require</B>
            not_off: <B>not</B> <A HREF="../elks/hash_table.html#f_off">off</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_key_for_iteration"><A HREF="../elks/hash_table.html#f_key_for_iteration">key_for_iteration</A>: K
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key at current iteration position</FONT>
        <B>require</B>
            not_off: <B>not</B> <A HREF="../elks/hash_table.html#f_off">off</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_cursor"><A HREF="../elks/hash_table.html#f_cursor">cursor</A>: <A HREF="../elks/cursor.html">CURSOR</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Current cursor position</FONT>
        <B>do</B>
            <B>create</B> {<A HREF="../elks/hash_table_cursor.html">HASH_TABLE_CURSOR</A>} <B>Result</B>.<A HREF="../elks/hash_table_cursor.html#f_make">make</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>ensure</B>
            cursor_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_new_cursor"><A HREF="../elks/hash_table.html#f_new_cursor">new_cursor</A>: <A HREF="../elks/hash_table_iteration_cursor.html">HASH_TABLE_ITERATION_CURSOR</A> [G, K]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Fresh cursor associated with current structure</FONT>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/readable_indexable_iteration_cursor.html#f_make">make</A> (<B>Current</B>);
            <B>Result</B>.<A HREF="../elks/readable_indexable_iteration_cursor.html#f_start">start</A>
        <B>end</B></A>

    <A NAME="f_iteration_item"><A HREF="../elks/hash_table.html#f_iteration_item">iteration_item</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): G
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Entry at position </FONT><I>i</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (i)
        <B>end</B></A>

    <A NAME="f_hash_code_of"><A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (a_key: <B>attached</B> K): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash_code value associated to </FONT><I>a_key</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := a_key.<A HREF="../elks/hashable.html#f_hash_code">hash_code</A>
        <B>ensure</B>
            non_negative: <B>Result</B> &gt;= 0
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_count"><A HREF="../elks/hash_table.html#f_count">count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of items in table</FONT>

    <A NAME="f_capacity"><A HREF="../elks/hash_table.html#f_capacity">capacity</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of items that may be stored.</FONT>

    <A NAME="f_occurrences"><A HREF="../elks/hash_table.html#f_occurrences">occurrences</A> (v: G): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of table items equal to </FONT><I>v</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            old_iteration_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            old_iteration_position := <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
            <B>if</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>from</B>
                    <A HREF="../elks/hash_table.html#f_start">start</A>
                <B>until</B>
                    <A HREF="../elks/hash_table.html#f_off">off</A>
                <B>loop</B>
                    <B>if</B> <A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A> ~ v <B>then</B>
                        <B>Result</B> := <B>Result</B> + 1
                    <B>end</B>
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    <A HREF="../elks/hash_table.html#f_start">start</A>
                <B>until</B>
                    <A HREF="../elks/hash_table.html#f_off">off</A>
                <B>loop</B>
                    <B>if</B> <A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A> = v <B>then</B>
                        <B>Result</B> := <B>Result</B> + 1
                    <B>end</B>
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := old_iteration_position
        <B>end</B></A>

    <A NAME="f_iteration_lower"><A HREF="../elks/hash_table.html#f_iteration_lower">iteration_lower</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Minimum index.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_next_iteration_position">next_iteration_position</A> (-1)
        <B>end</B></A>

    <A NAME="f_iteration_upper"><A HREF="../elks/hash_table.html#f_iteration_upper">iteration_upper</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Maximum index.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_previous_iteration_position">previous_iteration_position</A> (<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Comparison</FONT>

    <A NAME="f_is_equal"><A HREF="../elks/hash_table.html#f_is_equal">is_equal</A> (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does table contain the same information as </FONT><I>other</I><FONT COLOR="red">?</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_count">count</A> = other.<A HREF="../elks/hash_table.html#f_count">count</A> <B>and then</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> = other.<A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>and then</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> = other.<A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := <B>True</B>
                <B>across</B>
                    <B>Current</B> <B>as</B> l_c
                <B>until</B>
                    <B>not</B> <B>Result</B>
                <B>loop</B>
                    other.<A HREF="../elks/hash_table.html#f_search">search</A> (@l_c.key)
                    <B>if</B> other.<A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                        <B>if</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>then</B>
                            <B>Result</B> := l_c ~ other.<A HREF="../elks/hash_table.html#f_found_item">found_item</A>
                        <B>else</B>
                            <B>Result</B> := l_c = other.<A HREF="../elks/hash_table.html#f_found_item">found_item</A>
                        <B>end</B>
                    <B>else</B>
                        <B>Result</B> := <B>False</B>
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_same_keys"><A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (a_search_key, a_key: K): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does </FONT><I>a_search_key</I><FONT COLOR="red"> equal to </FONT><I>a_key</I><FONT COLOR="red">?</FONT>
        <B>do</B>
            <B>Result</B> := a_search_key ~ a_key
        <B>end</B></A>

    <A NAME="f_disjoint"><A HREF="../elks/hash_table.html#f_disjoint">disjoint</A> (other: <A HREF="../elks/hash_table.html">HASH_TABLE</A> [G, K]): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>Current</I><FONT COLOR="red"> and </FONT><I>other</I><FONT COLOR="red"> disjoint on their keys?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_same_keys">same_keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> for comparison.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>or else</B> other.<A HREF="../elks/finite.html#f_is_empty">is_empty</A> <B>or else</B> <B>not</B> <B>across</B>
                other <B>as</B> o
            <B>some</B>
                <A HREF="../elks/hash_table.html#f_has">has</A> (@o.key)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_full"><A HREF="../elks/hash_table.html#f_full">Full</A>: <A HREF="../elks/boolean.html">BOOLEAN</A> = <B>False</B></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is structure filled to capacity?</FONT>

    <A NAME="f_extendible"><A HREF="../elks/hash_table.html#f_extendible">Extendible</A>: <A HREF="../elks/boolean.html">BOOLEAN</A> = <B>False</B></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> May new items be added?</FONT>

    <A NAME="f_conflict"><A HREF="../elks/hash_table.html#f_conflict">conflict</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation cause a conflict?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_conflict_constant">Conflict_constant</A>
        <B>end</B></A>

    <A NAME="f_inserted"><A HREF="../elks/hash_table.html#f_inserted">inserted</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation insert an item?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_inserted_constant">Inserted_constant</A>
        <B>end</B></A>

    <A NAME="f_replaced"><A HREF="../elks/hash_table.html#f_replaced">replaced</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation replace an item?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_replaced_constant">Replaced_constant</A>
        <B>end</B></A>

    <A NAME="f_removed"><A HREF="../elks/hash_table.html#f_removed">removed</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation remove an item?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_removed_constant">Removed_constant</A>
        <B>end</B></A>

    <A NAME="f_found"><A HREF="../elks/hash_table.html#f_found">found</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation find the item sought?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_found_constant">Found_constant</A>
        <B>end</B></A>

    <A NAME="f_not_found"><A HREF="../elks/hash_table.html#f_not_found">not_found</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Did last operation fail to find the item sought?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> = <A HREF="../elks/hash_table.html#f_not_found_constant">Not_found_constant</A>
        <B>end</B></A>

    <A NAME="f_after"><A HREF="../elks/hash_table.html#f_after">after</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is cursor past last item?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT>{<A HREF="../elks/hash_table.html">HASH_TABLE</A>}<FONT COLOR="red"> as synonym of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_off">off</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_is_off_position">is_off_position</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_off"><A HREF="../elks/hash_table.html#f_off">off</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is cursor past last item?</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Was declared in </FONT>{<A HREF="../elks/hash_table.html">HASH_TABLE</A>}<FONT COLOR="red"> as synonym of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_after">after</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_is_off_position">is_off_position</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_valid_cursor"><A HREF="../elks/hash_table.html#f_valid_cursor">valid_cursor</A> (c: <A HREF="../elks/cursor.html">CURSOR</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Can cursor be moved to position </FONT><I>c</I><FONT COLOR="red">?</FONT>
        <B>require</B>
            c_not_void: c /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/hash_table_cursor.html">HASH_TABLE_CURSOR</A>} c <B>as</B> ht_cursor <B>then</B>
                i := ht_cursor.<A HREF="../elks/hash_table_cursor.html#f_position">position</A>
                <B>Result</B> := <A HREF="../elks/hash_table.html#f_is_off_position">is_off_position</A> (i) <B>or else</B> <A HREF="../elks/hash_table.html#f_truly_occupied">truly_occupied</A> (i)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_valid_key"><A HREF="../elks/hash_table.html#f_valid_key">valid_key</A> (k: K): <A HREF="../elks/boolean.html">BOOLEAN</A>
        <B>obsolete</B> "Remove the call to this feature or use `has` instead. [2018-11-30]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>k</I><FONT COLOR="red"> a valid key?</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
            <B>debug</B> ("prevent_hash_table_catcall")
                <B>if</B> <B>not</B> ({K}).<A HREF="../elks/type.html#f_is_expanded">is_expanded</A> <B>and then</B> <B>attached</B> k <B>then</B>
                    <B>Result</B> := k.<A HREF="../elks/any.html#f_generating_type">generating_type</A> ~ {<B>detachable</B> K}
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_valid_iteration_index"><A HREF="../elks/hash_table.html#f_valid_iteration_index">valid_iteration_index</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>i</I><FONT COLOR="red"> a valid index?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_truly_occupied">truly_occupied</A> (i)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor movement</FONT>

    <A NAME="f_start"><A HREF="../elks/hash_table.html#f_start">start</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Bring cursor to first position.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := <A HREF="../elks/hash_table.html#f_next_iteration_position">next_iteration_position</A> (-1)
        <B>end</B></A>

    <A NAME="f_forth"><A HREF="../elks/hash_table.html#f_forth">forth</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Advance cursor to next occupied position,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> or </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_off">off</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if no such position remains.</FONT>
        <B>require</B>
            not_off: <B>not</B> <A HREF="../elks/hash_table.html#f_off">off</A>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := <A HREF="../elks/hash_table.html#f_next_iteration_position">next_iteration_position</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
        <B>end</B></A>

    <A NAME="f_go_to"><A HREF="../elks/hash_table.html#f_go_to">go_to</A> (c: <A HREF="../elks/cursor.html">CURSOR</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Move to position </FONT><I>c</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            c_not_void: c /= <B>Void</B>
            valid_cursor: <A HREF="../elks/hash_table.html#f_valid_cursor">valid_cursor</A> (c)
        <B>do</B>
            <B>if</B> <B>attached</B> {<A HREF="../elks/hash_table_cursor.html">HASH_TABLE_CURSOR</A>} c <B>as</B> ht_cursor <B>then</B>
                <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := ht_cursor.<A HREF="../elks/hash_table_cursor.html#f_position">position</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_search"><A HREF="../elks/hash_table.html#f_search">search</A> (key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search for item of key </FONT><I>key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If found, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found">found</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to true, and set</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to item associated with </FONT><I>key</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            old_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_default_value: <B>detachable</B> G
        <B>do</B>
            old_position := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
            <B>else</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := old_position
        <B>ensure</B>
            found_or_not_found: <A HREF="../elks/hash_table.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            item_if_found: <A HREF="../elks/hash_table.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table.html#f_item">item</A> (key))
        <B>end</B></A>

    <A NAME="f_search_item"><A HREF="../elks/hash_table.html#f_search_item">search_item</A>: <B>detachable</B> G
        <B>obsolete</B> "Use `found_item` instead. [2017-05-31]"
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_found_item">found_item</A>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/hash_table_iteration_cursor.html">HASH_TABLE_ITERATION_CURSOR</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor movement</FONT>

    <A NAME="f_next_iteration_position"><A HREF="../elks/hash_table.html#f_next_iteration_position">next_iteration_position</A> (a_position: <B>like</B> <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>): <B>like</B> <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given an iteration position, advanced to the next one taking into account deleted</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> slots in the </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> and </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> structures.</FONT>
        <B>require</B>
            a_position_big_enough: a_position &gt;= -1
            a_position_small_enough: a_position &lt; <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
        <B>local</B>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_table_size: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_table_size := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_count">count</A>
            <B>from</B>
                <B>Result</B> := a_position + 1
            <B>until</B>
                <B>Result</B> &gt;= l_table_size <B>or else</B> <B>not</B> l_deleted_marks.<A HREF="../elks/special.html#f_item">item</A> (<B>Result</B>)
            <B>loop</B>
                <B>Result</B> := <B>Result</B> + 1
            <B>end</B>
        <B>ensure</B>
            is_increased: <B>Result</B> &gt; a_position
            is_below_upper_bound: <B>Result</B> &lt;= <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_previous_iteration_position"><A HREF="../elks/hash_table.html#f_previous_iteration_position">previous_iteration_position</A> (a_position: <B>like</B> <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>): <B>like</B> <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given an iteration position, go to the previous one taking into account deleted</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> slots in the </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> and </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> structures.</FONT>
        <B>require</B>
            a_position_big_enough: a_position &gt;= 0
            a_position_small_enough: a_position &lt;= <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
        <B>local</B>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
        <B>do</B>
            l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            <B>from</B>
                <B>Result</B> := a_position - 1
            <B>until</B>
                <B>Result</B> &lt;= -1 <B>or else</B> <B>not</B> l_deleted_marks.<A HREF="../elks/special.html#f_item">item</A> (<B>Result</B>)
            <B>loop</B>
                <B>Result</B> := <B>Result</B> - 1
            <B>end</B>
        <B>ensure</B>
            is_decreased: <B>Result</B> &lt; a_position
            is_above_lower_bound: <B>Result</B> &gt;= -1
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Element change</FONT>

    <A NAME="f_put"><A HREF="../elks/hash_table.html#f_put">put</A> (new: G; key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insert </FONT><I>new</I><FONT COLOR="red"> with </FONT><I>key</I><FONT COLOR="red"> if there is no other item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> associated with the same key.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_inserted">inserted</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if and only if an insertion has</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> been made (i.e. </FONT><I>key</I><FONT COLOR="red"> was not present).</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If so, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the insertion position.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_conflict">conflict</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> In either case, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> now associated with </FONT><I>key</I><FONT COLOR="red"> (previous item if</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> there was one, </FONT><I>new</I><FONT COLOR="red"> otherwise).</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see usage instructions at end of class.</FONT>
        <B>require else</B>
            <B>True</B>
        <B>local</B>
            l_default_key: <B>detachable</B> K
            l_new_pos, l_new_index_pos: <B>like</B> <A HREF="../elks/hash_table.html#f_position">position</A>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_set_conflict">set_conflict</A>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
            <B>else</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_soon_full">soon_full</A> <B>then</B>
                    <A HREF="../elks/hash_table.html#f_add_space">add_space</A>
                    <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
                    <B>check</B>
                        not_present: <B>not</B> <A HREF="../elks/hash_table.html#f_found">found</A>
                    <B>end</B>
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                    l_new_pos := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
                    l_new_index_pos := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
                <B>else</B>
                    l_new_pos := <A HREF="../elks/hash_table.html#f_deleted_position">deleted_position</A> (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>)
                    l_new_index_pos := <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>;
                    <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_force">force</A> (<B>False</B>, l_new_pos)
                <B>end</B>;
                <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_put">put</A> (l_new_pos, l_new_index_pos);
                <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_force">force</A> (new, l_new_pos);
                <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_force">force</A> (key, l_new_pos)
                <B>if</B> key = l_default_key <B>then</B>
                    <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>True</B>
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_count">count</A> := <A HREF="../elks/hash_table.html#f_count">count</A> + 1
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := new
                <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_inserted_constant">Inserted_constant</A>
            <B>end</B>
        <B>ensure then</B>
            conflict_or_inserted: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table.html#f_inserted">inserted</A>
            insertion_done: <A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>implies</B> <A HREF="../elks/hash_table.html#f_item">item</A> (key) = new
            now_present: <A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>implies</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)
            one_more_if_inserted: <A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A> + 1)
            unchanged_if_conflict: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A>)
            same_item_if_conflict: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (key) = <B>old</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (key)))
            found_item_associated_with_key: <A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table.html#f_item">item</A> (key)
            new_item_if_inserted: <A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = new)
            old_item_if_conflict: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <B>old</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (key)))
            default_property: <A HREF="../elks/hash_table.html#f_has_default">has_default</A> = ((<A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>and</B> (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>)) <B>or</B> ((<A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>or</B> (key /= <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>)) <B>and</B> (<B>old</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)))
        <B>end</B></A>

    <A NAME="f_force"><A HREF="../elks/hash_table.html#f_force">force</A> (new: G; key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Update table so that </FONT><I>new</I><FONT COLOR="red"> will be the item associated</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT><I>key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there was an item for that key, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found">found</A><FONT COLOR="red">`</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to that item.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there was none, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_not_found">not_found</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> and set</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the default value.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see usage instructions at end of class.</FONT>
        <B>require else</B>
            <B>True</B>
        <B>local</B>
            l_default_key: <B>detachable</B> K
            l_default_value: <B>detachable</B> G
            l_new_pos, l_new_index_pos: <B>like</B> <A HREF="../elks/hash_table.html#f_position">position</A>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A> <B>then</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_soon_full">soon_full</A> <B>then</B>
                    <A HREF="../elks/hash_table.html#f_add_space">add_space</A>
                    <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                    l_new_pos := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
                    l_new_index_pos := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
                <B>else</B>
                    l_new_pos := <A HREF="../elks/hash_table.html#f_deleted_position">deleted_position</A> (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>)
                    l_new_index_pos := <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>;
                    <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_force">force</A> (<B>False</B>, l_new_pos)
                <B>end</B>;
                <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_put">put</A> (l_new_pos, l_new_index_pos);
                <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_force">force</A> (key, l_new_pos)
                <B>if</B> key = l_default_key <B>then</B>
                    <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>True</B>
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_count">count</A> := <A HREF="../elks/hash_table.html#f_count">count</A> + 1
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <B>else</B>
                l_new_pos := <A HREF="../elks/hash_table.html#f_position">position</A>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (l_new_pos)
            <B>end</B>;
            <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_force">force</A> (new, l_new_pos)
        <B>ensure then</B>
            insertion_done: <A HREF="../elks/hash_table.html#f_item">item</A> (key) = new
            now_present: <A HREF="../elks/hash_table.html#f_has">has</A> (key)
            found_or_not_found: <A HREF="../elks/hash_table.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            not_found_if_was_not_present: <A HREF="../elks/hash_table.html#f_not_found">not_found</A> = <B>not</B> (<B>old</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key))
            same_count_or_one_more: (<A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A>) <B>or</B> (<A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A> + 1)
            found_item_is_old_item: <A HREF="../elks/hash_table.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <B>old</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (key)))
            default_value_if_not_found: <A HREF="../elks/hash_table.html#f_not_found">not_found</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <A HREF="../elks/hash_table.html#f_computed_default_value">computed_default_value</A>)
            default_property: <A HREF="../elks/hash_table.html#f_has_default">has_default</A> = ((key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>or</B> ((key /= <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>and</B> (<B>old</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)))
        <B>end</B></A>

    <A NAME="f_extend"><A HREF="../elks/hash_table.html#f_extend">extend</A> (new: G; key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assuming there is no item of key </FONT><I>key</I><FONT COLOR="red">,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> insert </FONT><I>new</I><FONT COLOR="red"> with </FONT><I>key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_inserted">inserted</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see usage instructions at end of class.</FONT>
        <B>require</B>
            not_present: <B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)
        <B>local</B>
            l_default_key: <B>detachable</B> K
            l_new_pos, l_new_index_pos: <B>like</B> <A HREF="../elks/hash_table.html#f_position">position</A>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_search_for_insertion">search_for_insertion</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_soon_full">soon_full</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_add_space">add_space</A>
                <A HREF="../elks/hash_table.html#f_search_for_insertion">search_for_insertion</A> (key)
            <B>end</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                l_new_pos := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
                l_new_index_pos := <A HREF="../elks/hash_table.html#f_item_position">item_position</A>
            <B>else</B>
                l_new_pos := <A HREF="../elks/hash_table.html#f_deleted_position">deleted_position</A> (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>)
                l_new_index_pos := <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>;
                <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_force">force</A> (<B>False</B>, l_new_pos)
            <B>end</B>;
            <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_put">put</A> (l_new_pos, l_new_index_pos);
            <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_force">force</A> (new, l_new_pos);
            <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_force">force</A> (key, l_new_pos)
            <B>if</B> key = l_default_key <B>then</B>
                <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>True</B>
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_count">count</A> := <A HREF="../elks/hash_table.html#f_count">count</A> + 1
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_inserted_constant">Inserted_constant</A>
        <B>ensure</B>
            inserted: <A HREF="../elks/hash_table.html#f_inserted">inserted</A>
            insertion_done: <A HREF="../elks/hash_table.html#f_item">item</A> (key) = new
            one_more: <A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A> + 1
            default_property: <A HREF="../elks/hash_table.html#f_has_default">has_default</A> = ((key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>or</B> (<B>old</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>))
        <B>end</B></A>

    <A NAME="f_replace"><A HREF="../elks/hash_table.html#f_replace">replace</A> (new: G; key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Replace item at </FONT><I>key</I><FONT COLOR="red">, if present,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT><I>new</I><FONT COLOR="red">; do not change associated key.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_replaced">replaced</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if and only if a replacement has been made</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (i.e. </FONT><I>key</I><FONT COLOR="red"> was present); otherwise set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_not_found">not_found</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the item previously associated</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with </FONT><I>key</I><FONT COLOR="red"> (default value if there was none).</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see usage instructions at end of class.</FONT>
        <B>local</B>
            l_default_item: <B>detachable</B> G
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>);
                <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_put">put</A> (new, <A HREF="../elks/hash_table.html#f_position">position</A>)
                <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_replaced_constant">Replaced_constant</A>
            <B>else</B>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_item
            <B>end</B>
        <B>ensure</B>
            replaced_or_not_found: <A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            insertion_done: <A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>implies</B> <A HREF="../elks/hash_table.html#f_item">item</A> (key) = new
            no_change_if_not_found: <A HREF="../elks/hash_table.html#f_not_found">not_found</A> <B>implies</B> <A HREF="../elks/hash_table.html#f_item">item</A> (key) = <B>old</B> <A HREF="../elks/hash_table.html#f_item">item</A> (key)
            found_item_is_old_item: <A HREF="../elks/hash_table.html#f_found_item">found_item</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_item">item</A> (key)
        <B>end</B></A>

    <A NAME="f_replace_key"><A HREF="../elks/hash_table.html#f_replace_key">replace_key</A> (new_key: K; old_key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If there is an item of key </FONT><I>old_key</I><FONT COLOR="red"> and no item of key</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>new_key</I><FONT COLOR="red">, replace the former's key by </FONT><I>new_key</I><FONT COLOR="red">,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_replaced">replaced</A><FONT COLOR="red">`</FONT><FONT COLOR="red">, and set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the item</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> previously associated with </FONT><I>old_key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Otherwise set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_not_found">not_found</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> or </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_conflict">conflict</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> respectively.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_conflict">conflict</A><FONT COLOR="red">`</FONT><FONT COLOR="red">, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to the item previously</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> associated with </FONT><I>new_key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To choose between various insert/replace procedures,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> see usage instructions at end of class.</FONT>
        <B>local</B>
            l_item: G
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (new_key)
            <B>if</B> <B>not</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (old_key)
                <B>if</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                    l_item := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
                    <A HREF="../elks/hash_table.html#f_remove">remove</A> (old_key)
                    <A HREF="../elks/hash_table.html#f_put">put</A> (l_item, new_key)
                    <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_replaced_constant">Replaced_constant</A>
                <B>end</B>
            <B>else</B>
                <A HREF="../elks/hash_table.html#f_set_conflict">set_conflict</A>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_position">position</A>)
            <B>end</B>
        <B>ensure</B>
            same_count: <A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A>
            replaced_or_conflict_or_not_found: <A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            old_absent: (<A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>and</B> <B>not</B> <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (new_key, old_key)) <B>implies</B> (<B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (old_key))
            new_present: (<A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table.html#f_conflict">conflict</A>) = <A HREF="../elks/hash_table.html#f_has">has</A> (new_key)
            new_item: <A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (new_key) = <B>old</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (old_key)))
            not_found_implies_no_old_key: <A HREF="../elks/hash_table.html#f_not_found">not_found</A> <B>implies</B> <B>old</B> (<B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (old_key))
            conflict_iff_already_present: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_has">has</A> (new_key)
            not_inserted_if_conflict: <A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_item">item</A> (new_key) = <B>old</B> <A HREF="../elks/hash_table.html#f_item">item</A> (new_key))
        <B>end</B></A>

    <A NAME="f_merge"><A HREF="../elks/hash_table.html#f_merge">merge</A> (other: <A HREF="../elks/hash_table.html">HASH_TABLE</A> [G, K])
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Merge </FONT><I>other</I><FONT COLOR="red"> into Current. If </FONT><I>other</I><FONT COLOR="red"> has some elements</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> with same key as in </FONT><I>Current</I><FONT COLOR="red">, replace them by one from</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>other</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            other_not_void: other /= <B>Void</B>
        <B>do</B>
            <B>if</B> other /= <B>Current</B> <B>then</B>
                <B>across</B>
                    other <B>as</B> o
                <B>loop</B>
                    <A HREF="../elks/hash_table.html#f_force">force</A> (o, @o.key)
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            inserted: <B></B> o: other <B></B>
                    item (.key) = o
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Removal</FONT>

    <A NAME="f_remove"><A HREF="../elks/hash_table.html#f_remove">remove</A> (key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove item associated with </FONT><I>key</I><FONT COLOR="red">, if present.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_removed">removed</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if and only if an item has been</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> removed (i.e. </FONT><I>key</I><FONT COLOR="red"> was present);</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> if so, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to index of removed element.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_not_found">not_found</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reset </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found_item">found_item</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to its default value if </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_removed">removed</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require else</B>
            <A HREF="../elks/dynamic_table.html#f_prunable">prunable</A>
        <B>local</B>
            l_default_key: <B>detachable</B> K
            l_default_value: <B>detachable</B> G
            l_pos: <B>like</B> <A HREF="../elks/hash_table.html#f_position">position</A>
            l_nb_removed_items: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key)
            <B>if</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>then</B>
                l_pos := <A HREF="../elks/hash_table.html#f_position">position</A>
                <B>if</B> key = l_default_key <B>then</B>
                    <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>False</B>
                <B>end</B>;
                <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_put">put</A> (<B>True</B>, l_pos);
                <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_put">put</A> (- l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>, <A HREF="../elks/hash_table.html#f_item_position">item_position</A>)
                <B>if</B> <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> = l_pos <B>then</B>
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_count">count</A> := <A HREF="../elks/hash_table.html#f_count">count</A> - 1
                <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := l_pos.<A HREF="../elks/comparable.html#f_min">min</A> (<A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>)
                <B>if</B> <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> = <A HREF="../elks/hash_table.html#f_count">count</A> <B>then</B>
                    l_nb_removed_items := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_count">count</A> - <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>;
                    <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_remove_tail">remove_tail</A> (l_nb_removed_items);
                    <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_remove_tail">remove_tail</A> (l_nb_removed_items);
                    <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_fill_with">fill_with</A> (<B>False</B>, <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>, <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_count">count</A> - 1)
                    <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_value
                    <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
                    <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table.html#f_ht_max_position">Ht_max_position</A>
                <B>elseif</B> <B>attached</B> <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A> <B>as</B> l_item <B>and</B> <B>attached</B> <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A> <B>as</B> l_key <B>then</B>
                    <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_put">put</A> (l_item, l_pos);
                    <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_put">put</A> (l_key, l_pos)
                <B>else</B>
                    <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A> := <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                    <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A> := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_removed_constant">Removed_constant</A>
                <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <B>end</B>
        <B>ensure then</B>
            removed_or_not_found: <A HREF="../elks/hash_table.html#f_removed">removed</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            not_present: <B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)
            one_less: <A HREF="../elks/hash_table.html#f_found">found</A> <B>implies</B> (<A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A> - 1)
            default_case: (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<B>not</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)
            non_default_case: (key /= <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>) <B>implies</B> (<A HREF="../elks/hash_table.html#f_has_default">has_default</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)
        <B>end</B></A>

    <A NAME="f_prune"><A HREF="../elks/hash_table.html#f_prune">prune</A> (v: G)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove first occurrence of </FONT><I>v</I><FONT COLOR="red">, if any,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> after cursor position.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Move cursor to right neighbor.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (or after if no right neighbor or </FONT><I>v</I><FONT COLOR="red"> does not occur)</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>from</B>
                <B>until</B>
                    <A HREF="../elks/hash_table.html#f_after">after</A> <B>or else</B> <A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A> ~ v
                <B>loop</B>
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                <B>until</B>
                    <A HREF="../elks/hash_table.html#f_after">after</A> <B>or else</B> <A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A> = v
                <B>loop</B>
                    <A HREF="../elks/hash_table.html#f_forth">forth</A>
                <B>end</B>
            <B>end</B>
            <B>if</B> <B>not</B> <A HREF="../elks/hash_table.html#f_after">after</A> <B>then</B>
                <A HREF="../elks/hash_table.html#f_remove">remove</A> (<A HREF="../elks/hash_table.html#f_key_for_iteration">key_for_iteration</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_wipe_out"><A HREF="../elks/hash_table.html#f_wipe_out">wipe_out</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Reset all items to default values; reset status.</FONT>
        <B>local</B>
            l_default_value: <B>detachable</B> G
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_wipe_out">wipe_out</A>;
            <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_wipe_out">wipe_out</A>;
            <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_fill_with">fill_with</A> (<B>False</B>, 0, <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_upper">upper</A>);
            <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_fill_with">fill_with</A> (<A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>, 0, <A HREF="../elks/hash_table.html#f_capacity">capacity</A>)
            <A HREF="../elks/hash_table.html#f_found_item">found_item</A> := l_default_value
            <A HREF="../elks/hash_table.html#f_count">count</A> := 0
            <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := 0
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
            <A HREF="../elks/hash_table.html#f_control">control</A> := 0
            <A HREF="../elks/hash_table.html#f_has_default">has_default</A> := <B>False</B>
        <B>ensure then</B>
            position_equal_to_zero: <A HREF="../elks/hash_table.html#f_item_position">item_position</A> = 0
            count_equal_to_zero: <A HREF="../elks/hash_table.html#f_count">count</A> = 0
            has_default_set: <B>not</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>
            no_status: <B>not</B> <A HREF="../elks/hash_table.html#f_special_status">special_status</A>
        <B>end</B></A>

    <A NAME="f_clear_all"><A HREF="../elks/hash_table.html#f_clear_all">clear_all</A>
        <B>obsolete</B> "Use `wipe_out' instead. [2017-05-31]"
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_wipe_out">wipe_out</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Conversion</FONT>

    <A NAME="f_linear_representation"><A HREF="../elks/hash_table.html#f_linear_representation">linear_representation</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [G]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Representation as a linear structure</FONT>
        <B>local</B>
            old_iteration_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            old_iteration_position := <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
            <B>from</B>
                <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (<A HREF="../elks/hash_table.html#f_count">count</A>)
                <A HREF="../elks/hash_table.html#f_start">start</A>
            <B>until</B>
                <A HREF="../elks/hash_table.html#f_off">off</A>
            <B>loop</B>
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<A HREF="../elks/hash_table.html#f_item_for_iteration">item_for_iteration</A>)
                <A HREF="../elks/hash_table.html#f_forth">forth</A>
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := old_iteration_position
        <B>ensure then</B>
            result_exists: <B>Result</B> /= <B>Void</B>
            good_count: <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_count">count</A> = <A HREF="../elks/hash_table.html#f_count">count</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_copy"><A HREF="../elks/hash_table.html#f_copy">copy</A> (other: <B>like</B> <B>Current</B>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Re-initialize from </FONT><I>other</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Current</B> <B>then</B>
                <A HREF="../elks/any.html#f_standard_copy">standard_copy</A> (other)
                <A HREF="../elks/hash_table.html#f_set_content">set_content</A> (other.<A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/any.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table.html#f_set_keys">set_keys</A> (other.<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/any.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table.html#f_set_deleted_marks">set_deleted_marks</A> (other.<A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/any.html#f_twin">twin</A>)
                <A HREF="../elks/hash_table.html#f_set_indexes_map">set_indexes_map</A> (other.<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/any.html#f_twin">twin</A>)
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_empty_duplicate"><A HREF="../elks/hash_table.html#f_empty_duplicate">empty_duplicate</A> (n: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <B>like</B> <B>Current</B>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create an empty copy of Current that can accommodate </FONT><I>n</I><FONT COLOR="red"> items</FONT>
        <B>require</B>
            n_non_negative: n &gt;= 0
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/hash_table.html#f_make">make</A> (n)
            <B>if</B> <A HREF="../elks/container.html#f_object_comparison">object_comparison</A> <B>then</B>
                <B>Result</B>.<A HREF="../elks/container.html#f_compare_objects">compare_objects</A>
            <B>end</B>
        <B>ensure</B>
            empty_duplicate_attached: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Transformation</FONT>

    <A NAME="f_correct_mismatch"><A HREF="../elks/hash_table.html#f_correct_mismatch">correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attempt to correct object mismatch during retrieve using </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/mismatch_corrector.html#f_mismatch_information">mismatch_information</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>local</B>
            l_old_deleted_marks: <B>detachable</B> <A HREF="../elks/special.html">SPECIAL</A> [<A HREF="../elks/boolean.html">BOOLEAN</A>]
            i, l_capacity, l_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_new_table: <B>like</B> <B>Current</B>
            l_default_item: <B>like</B> <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A>
            l_default_key: <B>like</B> <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A>
        <B>do</B>
            <B>if</B> <B>not</B> <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_has">has</A> ("hash_table_version_64") <B>then</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array.html">ARRAY</A> [G]} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_item">item</A> ("content") <B>as</B> array_content <B>then</B>
                    <A HREF="../elks/hash_table.html#f_content">content</A> := array_content.<A HREF="../elks/to_special.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array.html">ARRAY</A> [K]} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_item">item</A> ("keys") <B>as</B> array_keys <B>then</B>
                    <A HREF="../elks/hash_table.html#f_keys">keys</A> := array_keys.<A HREF="../elks/to_special.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/array.html">ARRAY</A> [<A HREF="../elks/boolean.html">BOOLEAN</A>]} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_item">item</A> ("deleted_marks") <B>as</B> array_marks <B>then</B>
                    <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A> := array_marks.<A HREF="../elks/to_special.html#f_area">area</A>
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A> /= <B>Void</B> <B>and</B> <A HREF="../elks/hash_table.html#f_keys">keys</A> /= <B>Void</B> <B>and then</B> <B>not</B> <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_has">has</A> ("hash_table_version_57") <B>and then</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_count">count</A> /= <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> <B>then</B>
                    l_old_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    <B>create</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_make_empty">make_empty</A> (<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>);
                    <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_copy_data">copy_data</A> (l_old_deleted_marks, 0, 0, l_old_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>)
                <B>end</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/integer_32.html">INTEGER_32</A>} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_item">item</A> ("count") <B>as</B> l_retrieved_count <B>then</B>
                    l_count := l_retrieved_count
                <B>end</B>
                <B>if</B> <A HREF="../elks/hash_table.html#f_content">content</A> = <B>Void</B> <B>or</B> <A HREF="../elks/hash_table.html#f_keys">keys</A> = <B>Void</B> <B>or</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A> = <B>Void</B> <B>then</B>
                    <B>Precursor</B> {<A HREF="../elks/mismatch_corrector.html">MISMATCH_CORRECTOR</A>}
                <B>else</B>
                    <B>from</B>
                        l_capacity := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
                        l_new_table := <A HREF="../elks/hash_table.html#f_empty_duplicate">empty_duplicate</A> (l_count)
                    <B>until</B>
                        i = l_capacity
                    <B>loop</B>
                        <B>if</B> <B>attached</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (i) <B>as</B> l_key_item <B>and then</B> l_key_item /= l_default_key <B>then</B>
                            l_new_table.<A HREF="../elks/hash_table.html#f_put">put</A> (<A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (i), l_key_item)
                        <B>end</B>
                        i := i + 1
                    <B>end</B>
                    <B>if</B> <B>attached</B> {<A HREF="../elks/boolean.html">BOOLEAN</A>} <A HREF="../elks/mismatch_corrector.html#f_mismatch_information">Mismatch_information</A>.<A HREF="../elks/hash_table.html#f_item">item</A> ("has_default") <B>as</B> l_bool <B>and then</B> l_bool <B>then</B>
                        l_new_table.<A HREF="../elks/hash_table.html#f_put">put</A> (<A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_capacity">capacity</A> - 1), <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (l_capacity - 1))
                    <B>end</B>
                    <A HREF="../elks/hash_table.html#f_set_content">set_content</A> (l_new_table.<A HREF="../elks/hash_table.html#f_content">content</A>)
                    <A HREF="../elks/hash_table.html#f_set_keys">set_keys</A> (l_new_table.<A HREF="../elks/hash_table.html#f_keys">keys</A>)
                    <A HREF="../elks/hash_table.html#f_set_deleted_marks">set_deleted_marks</A> (l_new_table.<A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>)
                    <A HREF="../elks/hash_table.html#f_set_indexes_map">set_indexes_map</A> (l_new_table.<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>)
                    <A HREF="../elks/hash_table.html#f_capacity">capacity</A> := l_new_table.<A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    <A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A> := l_new_table.<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>
                    <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> := l_new_table.<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>
                    <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := l_new_table.<A HREF="../elks/hash_table.html#f_item_position">item_position</A>
                    <A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A> := <A HREF="../elks/hash_table.html#f_ht_max_position">Ht_max_position</A>
                    <A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A> := l_default_item
                    <A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A> := l_default_key
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_control">control</A> := 0
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_hash_table_version_64"><A HREF="../elks/hash_table.html#f_hash_table_version_64">hash_table_version_64</A>: <A HREF="../elks/boolean.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Fake attribute for versioning purposes. Used in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_correct_mismatch">correct_mismatch</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
    
<B>feature</B> {<A HREF="../elks/hash_table.html">HASH_TABLE</A>, <A HREF="../elks/hash_table_iteration_cursor.html">HASH_TABLE_ITERATION_CURSOR</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: content attributes and preservation</FONT>

    <A NAME="f_content"><A HREF="../elks/hash_table.html#f_content">content</A>: <A HREF="../elks/special.html">SPECIAL</A> [G]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Array of contents</FONT>

    <A NAME="f_keys"><A HREF="../elks/hash_table.html#f_keys">keys</A>: <A HREF="../elks/special.html">SPECIAL</A> [K]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Array of keys</FONT>
    
<B>feature</B> {<A HREF="../elks/hash_table.html">HASH_TABLE</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: content attributes and preservation</FONT>

    <A NAME="f_indexes_map"><A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>: <A HREF="../elks/special.html">SPECIAL</A> [<A HREF="../elks/integer_32.html">INTEGER_32</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Indexes of items in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red">, and </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If item is not present, then it has </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_ht_impossible_position">ht_impossible_position</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If item is deleted, then it has </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_ht_deleted_position">ht_deleted_position</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>

    <A NAME="f_deleted_marks"><A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>: <A HREF="../elks/special.html">SPECIAL</A> [<A HREF="../elks/boolean.html">BOOLEAN</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Indexes of deleted positions in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> and </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>

    <A NAME="f_item_position"><A HREF="../elks/hash_table.html#f_item_position">item_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> for item at position </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red">. Set by </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_internal_search">internal_search</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>

    <A NAME="f_has_default"><A HREF="../elks/hash_table.html#f_has_default">has_default</A>: <A HREF="../elks/boolean.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the default key present?</FONT>
    
<B>feature</B> {<A HREF="../elks/hash_table.html">HASH_TABLE</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation: search attributes</FONT>

    <A NAME="f_iteration_position"><A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Cursor for iteration primitives</FONT>

    <A NAME="f_position"><A HREF="../elks/hash_table.html#f_position">position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash table cursor, updated after each operation:</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> put, remove, has, replace, force, change_key...</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_item_position">item_position</A>)
        <B>end</B></A>

    <A NAME="f_soon_full"><A HREF="../elks/hash_table.html#f_soon_full">soon_full</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is table close to being filled to current capacity?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> = <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_capacity">capacity</A>
        <B>ensure</B>
            <B>Result</B> = (<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> = <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_capacity">capacity</A>)
        <B>end</B></A>

    <A NAME="f_control"><A HREF="../elks/hash_table.html#f_control">control</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Control code set by operations that may produce</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> several possible conditions.</FONT>

    <A NAME="f_deleted_item_position"><A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Place where a deleted element was found during a search</FONT>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_ht_max_position"><A HREF="../elks/hash_table.html#f_ht_max_position">Ht_max_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 2147483645</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Maximum possible position</FONT>

    <A NAME="f_ht_impossible_position"><A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = -1</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Position outside the array indices.</FONT>

    <A NAME="f_ht_deleted_position"><A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = -2</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Marked a deleted position.</FONT>

    <A NAME="f_ht_lowest_deleted_position"><A HREF="../elks/hash_table.html#f_ht_lowest_deleted_position">ht_lowest_deleted_position</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Index of the lowest deleted position thus far.</FONT>

    <A NAME="f_ht_deleted_item"><A HREF="../elks/hash_table.html#f_ht_deleted_item">ht_deleted_item</A>: <B>detachable</B> G</A>

    <A NAME="f_ht_deleted_key"><A HREF="../elks/hash_table.html#f_ht_deleted_key">ht_deleted_key</A>: <B>detachable</B> K</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Store the item and key that will be used to replace an element of the HASH_TABLE</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> that will be removed. If elements being removed are at the end of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> or </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> then they are both Void. It is only used when removing an element at a position strictly</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> less than </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_count">count</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>

    <A NAME="f_deleted_position"><A HREF="../elks/hash_table.html#f_deleted_position">deleted_position</A> (a_pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Given the position of a deleted item at </FONT><I>a_pos</I><FONT COLOR="red"> gives the associated position</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in </FONT><I>content/keys</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            deleted: <A HREF="../elks/hash_table.html#f_deleted">deleted</A> (a_pos)
        <B>do</B>
            <B>Result</B> := - <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (a_pos) + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
            <B>Result</B> := <B>Result</B>.<A HREF="../elks/comparable.html#f_min">min</A> (<A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>)
        <B>ensure</B>
            deleted_position_non_negative: <B>Result</B> &gt;= 0
            deleted_position_valid: <B>Result</B> &lt;= <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> <B>and</B> <B>Result</B> &lt;= <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_occupied"><A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT><I>i</I><FONT COLOR="red"> occupied by a non-default key and a value?</FONT>
        <B>require</B>
            in_bounds: <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_valid_index">valid_index</A> (i)
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                <B>Result</B> := i /= <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>) <B>and then</B> <B>not</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_item">item</A> (i)
            <B>else</B>
                <B>Result</B> := <B>not</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>.<A HREF="../elks/special.html#f_item">item</A> (i)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_truly_occupied"><A HREF="../elks/hash_table.html#f_truly_occupied">truly_occupied</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT><I>i</I><FONT COLOR="red"> occupied by a key and a value?</FONT>
        <B>do</B>
            <B>if</B> i &gt;= 0 <B>and</B> i &lt; <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> <B>then</B>
                <B>Result</B> := (<A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>and</B> i = <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>)) <B>or else</B> <A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i)
            <B>end</B>
        <B>ensure</B>
            normal_key: (i &gt;= 0 <B>and</B> i &lt; <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> <B>and</B> i /= <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>)) <B>implies</B> (<A HREF="../elks/hash_table.html#f_occupied">occupied</A> (i) <B>implies</B> <B>Result</B>)
            default_key: (i = <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (<A HREF="../elks/hash_table.html#f_capacity">capacity</A>)) <B>implies</B> (<B>Result</B> = <A HREF="../elks/hash_table.html#f_has_default">has_default</A>)
        <B>end</B></A>

    <A NAME="f_is_off_position"><A HREF="../elks/hash_table.html#f_is_off_position">is_off_position</A> (pos: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>pos</I><FONT COLOR="red"> a cursor position outside the authorized range?</FONT>
        <B>do</B>
            <B>Result</B> := pos &lt; 0 <B>or</B> pos &gt;= <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A>
        <B>end</B></A>

    <A NAME="f_set_content"><A HREF="../elks/hash_table.html#f_set_content">set_content</A> (c: <B>like</B> <A HREF="../elks/hash_table.html#f_content">content</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT><I>c</I><FONT COLOR="red"> to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require</B>
            c_attached: c /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_content">content</A> := c
        <B>ensure</B>
            content_set: <A HREF="../elks/hash_table.html#f_content">content</A> = c
        <B>end</B></A>

    <A NAME="f_deleted"><A HREF="../elks/hash_table.html#f_deleted">deleted</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is position </FONT><I>i</I><FONT COLOR="red"> that of a deleted item?</FONT>
        <B>require</B>
            in_bounds: i &gt;= 0 <B>and</B> i &lt;= <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>.<A HREF="../elks/special.html#f_item">item</A> (i) &lt;= <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
        <B>end</B></A>

    <A NAME="f_set_keys"><A HREF="../elks/hash_table.html#f_set_keys">set_keys</A> (c: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT><I>c</I><FONT COLOR="red"> to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_keys">keys</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require</B>
            c_attached: c /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_keys">keys</A> := c
        <B>ensure</B>
            keys_set: <A HREF="../elks/hash_table.html#f_keys">keys</A> = c
        <B>end</B></A>

    <A NAME="f_set_deleted_marks"><A HREF="../elks/hash_table.html#f_set_deleted_marks">set_deleted_marks</A> (d: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT><I>c</I><FONT COLOR="red"> to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_content">content</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require</B>
            d_attached: d /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A> := d
        <B>ensure</B>
            deleted_marks_set: <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A> = d
        <B>end</B></A>

    <A NAME="f_set_indexes_map"><A HREF="../elks/hash_table.html#f_set_indexes_map">set_indexes_map</A> (v: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assign </FONT><I>v</I><FONT COLOR="red"> to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A> := v
        <B>ensure</B>
            indexes_map_set: <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A> = v
        <B>end</B></A>

    <A NAME="f_default_key_value"><A HREF="../elks/hash_table.html#f_default_key_value">default_key_value</A>: G
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Value associated with the default key, if any</FONT>
        <B>require</B>
            has_default: <A HREF="../elks/hash_table.html#f_has_default">has_default</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_content">content</A> [<A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A> [<A HREF="../elks/hash_table.html#f_capacity">capacity</A>]]
        <B>end</B></A>

    <A NAME="f_computed_default_key"><A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>: <B>detachable</B> K
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default key</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (For performance reasons, used only in assertions;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> elsewhere, see use of local entity </FONT><I>l_default_key</I><FONT COLOR="red">.)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_computed_default_value"><A HREF="../elks/hash_table.html#f_computed_default_value">computed_default_value</A>: <B>detachable</B> G
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Default value of type G</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> (For performance reasons, used only in assertions;</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> elsewhere, see use of local entity </FONT><I>l_default_value</I><FONT COLOR="red">.)</FONT>
        <B>do</B>
        <B>end</B></A>

    <A NAME="f_internal_search"><A HREF="../elks/hash_table.html#f_internal_search">internal_search</A> (key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Search for item of key </FONT><I>key</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If successful, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to index</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of item with this key (the same index as the key's index).</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> If not, set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to possible position for insertion,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> and set status to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_found">found</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> or </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_not_found">not_found</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>local</B>
            l_default_key: <B>detachable</B> K
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_keys: <B>like</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
            l_key: K
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                <B>if</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A> <B>then</B>
                    <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_found_constant">Found_constant</A>
                <B>else</B>
                    <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_not_found_constant">Not_found_constant</A>
                <B>end</B>
            <B>else</B>
                <B>from</B>
                    l_keys := <A HREF="../elks/hash_table.html#f_keys">keys</A>
                    l_indexes := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                    <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_not_found_constant">Not_found_constant</A>
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                        l_key := l_keys.<A HREF="../elks/special.html#f_item">item</A> (l_pos)
                        <B>debug</B> ("detect_hash_table_catcall")
                            <B>check</B>
                                catcall_detected: l_key /= <B>Void</B> <B>and then</B> l_key.<A HREF="../elks/any.html#f_same_type">same_type</A> (key)
                            <B>end</B>
                        <B>end</B>
                        <B>if</B> <A HREF="../elks/hash_table.html#f_same_keys">same_keys</A> (l_key, key) <B>then</B>
                            stop := 1
                            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_found_constant">Found_constant</A>
                        <B>end</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := l_item_pos
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> := l_first_deleted_position
        <B>ensure</B>
            found_or_not_found: <A HREF="../elks/hash_table.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
            deleted_item_at_deleted_position: (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> /= <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>) <B>implies</B> <A HREF="../elks/hash_table.html#f_deleted">deleted</A> (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>)
            default_iff_at_capacity: (<A HREF="../elks/hash_table.html#f_item_position">item_position</A> = <A HREF="../elks/hash_table.html#f_capacity">capacity</A>) = (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>)
        <B>end</B></A>

    <A NAME="f_search_for_insertion"><A HREF="../elks/hash_table.html#f_search_for_insertion">search_for_insertion</A> (key: K)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Assuming there is no item of key </FONT><I>key</I><FONT COLOR="red">, compute</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_position">position</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> at which to insert such an item.</FONT>
        <B>require</B>
            not_present: <B>not</B> <A HREF="../elks/hash_table.html#f_has">has</A> (key)
        <B>local</B>
            l_default_key: <B>detachable</B> K
            hash_value, increment, l_pos, l_item_pos, l_capacity: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_first_deleted_position: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            stop: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            l_indexes: <B>like</B> <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
            l_deleted_marks: <B>like</B> <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
        <B>do</B>
            l_first_deleted_position := <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>
            <B>if</B> key = l_default_key <B>or</B> key = <B>Void</B> <B>then</B>
                <B>check</B>
                    <B>not</B> <A HREF="../elks/hash_table.html#f_has_default">has_default</A>
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
            <B>else</B>
                <B>from</B>
                    l_indexes := <A HREF="../elks/hash_table.html#f_indexes_map">indexes_map</A>
                    l_deleted_marks := <A HREF="../elks/hash_table.html#f_deleted_marks">deleted_marks</A>
                    l_capacity := <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
                    stop := l_capacity
                    hash_value := <A HREF="../elks/hash_table.html#f_hash_code_of">hash_code_of</A> (key)
                    increment := 1 + hash_value \\ (l_capacity - 1)
                    l_item_pos := (hash_value \\ l_capacity) - increment
                <B>until</B>
                    stop = 0
                <B>loop</B>
                    l_item_pos := (l_item_pos + increment) \\ l_capacity
                    l_pos := l_indexes [l_item_pos]
                    <B>if</B> l_pos &gt;= 0 <B>then</B>
                    <B>elseif</B> l_pos = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        stop := 1
                    <B>elseif</B> l_first_deleted_position = <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A> <B>then</B>
                        l_pos := - l_pos + <A HREF="../elks/hash_table.html#f_ht_deleted_position">Ht_deleted_position</A>
                        <B>check</B>
                            l_pos_valid: l_pos &lt; l_deleted_marks.<A HREF="../elks/special.html#f_count">count</A>
                        <B>end</B>
                        <B>if</B> <B>not</B> l_deleted_marks [l_pos] <B>then</B>
                            stop := 1
                        <B>else</B>
                            l_first_deleted_position := l_item_pos
                        <B>end</B>
                    <B>end</B>
                    stop := stop - 1
                <B>end</B>
                <A HREF="../elks/hash_table.html#f_item_position">item_position</A> := l_item_pos
            <B>end</B>
            <A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> := l_first_deleted_position
        <B>ensure</B>
            deleted_item_at_deleted_position: (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A> /= <A HREF="../elks/hash_table.html#f_ht_impossible_position">Ht_impossible_position</A>) <B>implies</B> <A HREF="../elks/hash_table.html#f_deleted">deleted</A> (<A HREF="../elks/hash_table.html#f_deleted_item_position">deleted_item_position</A>)
            default_iff_at_capacity: (<A HREF="../elks/hash_table.html#f_item_position">item_position</A> = <A HREF="../elks/hash_table.html#f_capacity">capacity</A>) = (key = <A HREF="../elks/hash_table.html#f_computed_default_key">computed_default_key</A>)
        <B>end</B></A>

    <A NAME="f_key_at"><A HREF="../elks/hash_table.html#f_key_at">key_at</A> (n: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <B>detachable</B> K
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key at position </FONT><I>n</I>
        <B>do</B>
            <B>if</B> <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_valid_index">valid_index</A> (n) <B>then</B>
                <B>Result</B> := <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_item">item</A> (n)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_initial_position"><A HREF="../elks/hash_table.html#f_initial_position">initial_position</A> (hash_value: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initial position for an item of hash code </FONT><I>hash_value</I>
        <B>do</B>
            <B>Result</B> := hash_value \\ <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
        <B>end</B></A>

    <A NAME="f_position_increment"><A HREF="../elks/hash_table.html#f_position_increment">position_increment</A> (hash_value: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Distance between successive positions for hash code</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>hash_value</I><FONT COLOR="red"> (computed for no cycle: </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/hash_table.html#f_capacity">capacity</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> is prime)</FONT>
        <B>do</B>
            <B>Result</B> := 1 + hash_value \\ (<A HREF="../elks/hash_table.html#f_capacity">capacity</A> - 1)
        <B>end</B></A>

    <A NAME="f_conflict_constant"><A HREF="../elks/hash_table.html#f_conflict_constant">Conflict_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 1</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Could not insert an already existing key</FONT>

    <A NAME="f_set_conflict"><A HREF="../elks/hash_table.html#f_set_conflict">set_conflict</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to conflict.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_conflict_constant">Conflict_constant</A>
        <B>ensure</B>
            conflict: <A HREF="../elks/hash_table.html#f_conflict">conflict</A>
        <B>end</B></A>

    <A NAME="f_found_constant"><A HREF="../elks/hash_table.html#f_found_constant">Found_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 2</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key found</FONT>

    <A NAME="f_set_found"><A HREF="../elks/hash_table.html#f_set_found">set_found</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to found.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_found_constant">Found_constant</A>
        <B>ensure</B>
            found: <A HREF="../elks/hash_table.html#f_found">found</A>
        <B>end</B></A>

    <A NAME="f_inserted_constant"><A HREF="../elks/hash_table.html#f_inserted_constant">Inserted_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 4</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insertion successful</FONT>

    <A NAME="f_set_inserted"><A HREF="../elks/hash_table.html#f_set_inserted">set_inserted</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to inserted.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_inserted_constant">Inserted_constant</A>
        <B>ensure</B>
            inserted: <A HREF="../elks/hash_table.html#f_inserted">inserted</A>
        <B>end</B></A>

    <A NAME="f_not_found_constant"><A HREF="../elks/hash_table.html#f_not_found_constant">Not_found_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Key not found</FONT>

    <A NAME="f_set_not_found"><A HREF="../elks/hash_table.html#f_set_not_found">set_not_found</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to not found.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_not_found_constant">Not_found_constant</A>
        <B>ensure</B>
            not_found: <A HREF="../elks/hash_table.html#f_not_found">not_found</A>
        <B>end</B></A>

    <A NAME="f_set_no_status"><A HREF="../elks/hash_table.html#f_set_no_status">set_no_status</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to normal.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := 0
        <B>ensure</B>
            default_status: <B>not</B> <A HREF="../elks/hash_table.html#f_special_status">special_status</A>
        <B>end</B></A>

    <A NAME="f_removed_constant"><A HREF="../elks/hash_table.html#f_removed_constant">Removed_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 16</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Remove successful</FONT>

    <A NAME="f_set_removed"><A HREF="../elks/hash_table.html#f_set_removed">set_removed</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to removed.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_removed_constant">Removed_constant</A>
        <B>ensure</B>
            removed: <A HREF="../elks/hash_table.html#f_removed">removed</A>
        <B>end</B></A>

    <A NAME="f_replaced_constant"><A HREF="../elks/hash_table.html#f_replaced_constant">Replaced_constant</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Replaced value</FONT>

    <A NAME="f_set_replaced"><A HREF="../elks/hash_table.html#f_set_replaced">set_replaced</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set status to replaced.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_control">control</A> := <A HREF="../elks/hash_table.html#f_replaced_constant">Replaced_constant</A>
        <B>ensure</B>
            replaced: <A HREF="../elks/hash_table.html#f_replaced">replaced</A>
        <B>end</B></A>

    <A NAME="f_special_status"><A HREF="../elks/hash_table.html#f_special_status">special_status</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Has status been set to some non-default value?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/hash_table.html#f_control">control</A> &gt; 0
        <B>ensure</B>
            <B>Result</B> = (<A HREF="../elks/hash_table.html#f_control">control</A> &gt; 0)
        <B>end</B></A>

    <A NAME="f_add_space"><A HREF="../elks/hash_table.html#f_add_space">add_space</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Increase capacity.</FONT>
        <B>do</B>
            <A HREF="../elks/hash_table.html#f_accommodate">accommodate</A> (<A HREF="../elks/hash_table.html#f_count">count</A> + <A HREF="../elks/hash_table.html#f_count">count</A> // 2)
        <B>ensure</B>
            count_not_changed: <A HREF="../elks/hash_table.html#f_count">count</A> = <B>old</B> <A HREF="../elks/hash_table.html#f_count">count</A>
            breathing_space: <A HREF="../elks/hash_table.html#f_count">count</A> &lt; <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
        <B>end</B></A>

    <A NAME="f_minimum_capacity"><A HREF="../elks/hash_table.html#f_minimum_capacity">Minimum_capacity</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 2</A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Inapplicable</FONT>

    <A NAME="f_collection_extend"><A HREF="../elks/hash_table.html#f_collection_extend">collection_extend</A> (v: G)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Insert a new occurrence of </FONT><I>v</I><FONT COLOR="red">.</FONT>
        <B>do</B>
        <B>end</B></A>
    
<B>invariant</B>
    keys_not_void: <A HREF="../elks/hash_table.html#f_keys">keys</A> /= <B>Void</B>
    content_not_void: <A HREF="../elks/hash_table.html#f_content">content</A> /= <B>Void</B>
    keys_enough_capacity: <A HREF="../elks/hash_table.html#f_keys">keys</A>.<A HREF="../elks/special.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table.html#f_capacity">capacity</A> + 1
    content_enough_capacity: <A HREF="../elks/hash_table.html#f_content">content</A>.<A HREF="../elks/special.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table.html#f_capacity">capacity</A> + 1
    valid_iteration_position: <A HREF="../elks/hash_table.html#f_off">off</A> <B>or</B> <A HREF="../elks/hash_table.html#f_truly_occupied">truly_occupied</A> (<A HREF="../elks/hash_table.html#f_iteration_position">iteration_position</A>)
    control_non_negative: <A HREF="../elks/hash_table.html#f_control">control</A> &gt;= 0
    special_status: <A HREF="../elks/hash_table.html#f_special_status">special_status</A> = (<A HREF="../elks/hash_table.html#f_conflict">conflict</A> <B>or</B> <A HREF="../elks/hash_table.html#f_inserted">inserted</A> <B>or</B> <A HREF="../elks/hash_table.html#f_replaced">replaced</A> <B>or</B> <A HREF="../elks/hash_table.html#f_removed">removed</A> <B>or</B> <A HREF="../elks/hash_table.html#f_found">found</A> <B>or</B> <A HREF="../elks/hash_table.html#f_not_found">not_found</A>)
    count_big_enough: 0 &lt;= <A HREF="../elks/hash_table.html#f_count">count</A>
    count_small_enough: <A HREF="../elks/hash_table.html#f_count">count</A> &lt;= <A HREF="../elks/hash_table.html#f_capacity">capacity</A>
    slot_count_big_enough: 0 &lt;= <A HREF="../elks/hash_table.html#f_count">count</A>

<B>note</B>
    instruction: "[
        		Several procedures are provided for inserting an item
        		with a given key.
        
        		Here is how to choose between them:
        
        			- Use `<A HREF="../elks/hash_table.html#f_put">put</A>` if you want to do an insertion only if
        			  there was no item with the given key, doing nothing
        			  otherwise. (You can find out on return if there was one,
        			  and what it was.)
        
        			- Use `<A HREF="../elks/hash_table.html#f_force">force</A>` if you always want to insert the item;
        			  if there was one for the given key it will be removed,
        			  (and you can find out on return what it was).
        
        			- Use `<A HREF="../elks/hash_table.html#f_extend">extend</A>` if you are sure there is no item with
        			  the given key, enabling faster insertion (but
        			  unpredictable behavior if this assumption is not true).
        
        			- Use `<A HREF="../elks/hash_table.html#f_replace">replace</A>` if you want to replace an already present
        			  item with the given key, and do nothing if there is none.
        
        		In addition you can use `<A HREF="../elks/hash_table.html#f_replace_key">replace_key</A>` to change the key of an
        		already present item, identified by its previous key, or
        		do nothing if there is nothing for that previous key.
        		You can find out on return.
        
        		To find out whether a key appears in the table, use `<A HREF="../elks/hash_table.html#f_has">has</A>`.
        		To find out the item, if any, associated with a certain key,
        		use `<A HREF="../elks/hash_table.html#f_item">item</A>`.
        
        		Both of these routines perform a search. If you need
        		both pieces of information (does a key appear? And, if so,
        		what is the associated item?), you can avoid performing
        		two redundant traversals by using instead the combination
        		of `<A HREF="../elks/hash_table.html#f_search">search</A>`, `<A HREF="../elks/hash_table.html#f_found">found</A>` and `<A HREF="../elks/hash_table.html#f_found_item">found_item</A>` as follows:
        
        			your_table.search (your_key)
        			if your_table.found then
        				what_you_where_looking_for := your_table.found_item
        				... Do whatever is needed to what_you_were_looking_for ...
        			else
        				... No item was present for your_key ...
        			end
    ]"
    date: "$Date: 2021-06-18 17:01:52 +0000 (Fri, 18 Jun 2021) $"
    revision: "$Revision: 105548 $"
    copyright: "Copyright (c) 1984-2021, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/hash_table.html">HASH_TABLE</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="hash_table_chart.html">Chart</A></TD><TD><A HREF="hash_table_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

