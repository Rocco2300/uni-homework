<HTML><HEAD>
<meta name="description" content="Helper routines for encoding conversion."/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="library" content="Encoding: Library of reusable components for Eiffel."/>
<meta name="copyright" content="Copyright (c) 1984-2020, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>encoding_helper Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../../class_list.html">Classes</A></TD><TD><A HREF="../../cluster_list.html">Clusters</A></TD><TD><A HREF="../../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="encoding_helper_chart.html">Chart</A></TD><TD><A HREF="encoding_helper_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "Helper routines for encoding conversion."
    legal: "See notice at end of class."
    status: "See notice at end of class."
    date: "$Date: 2020-05-19 14:18:09 +0000 (Tue, 19 May 2020) $"
    revision: "$Revision: 104255 $"

<B>class</B> 
    <A HREF="../../elks/encoding/encoding_helper.html">ENCODING_HELPER</A>

<B>create</B> 
    <A HREF="../../elks/any.html#f_default_create">default_create</A>

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Conversion</FONT>

    <A NAME="f_multi_byte_to_pointer"><A HREF="../../elks/encoding/encoding_helper.html#f_multi_byte_to_pointer">multi_byte_to_pointer</A> (a_string: <A HREF="../../elks/readable_string_8.html">READABLE_STRING_8</A>): <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Managed pointer of </FONT><I>a_string</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <B>Result</B> := (<B>create</B> {<A HREF="../../elks/c_string.html">C_STRING</A>}.<A HREF="../../elks/c_string.html#f_make">make</A> (a_string) <B>end</B>).<A HREF="../../elks/c_string.html#f_managed_data">managed_data</A>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_wide_string_to_pointer"><A HREF="../../elks/encoding/encoding_helper.html#f_wide_string_to_pointer">wide_string_to_pointer</A> (a_string: <A HREF="../../elks/readable_string_32.html">READABLE_STRING_32</A>): <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Managed pointer of </FONT><I>a_string</I><FONT COLOR="red"> which is taken as</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> 16bits string. High 16bits of characters of </FONT><I>a_string</I><FONT COLOR="red"> are discarded.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>local</B>
            i, nb: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            nb := a_string.<A HREF="../../elks/readable_string_32.html#f_count">count</A>
            <B>create</B> <B>Result</B>.<A HREF="../../elks/managed_pointer.html#f_make">make</A> ((nb + 1) * 2)
            <B>from</B>
                i := 0
            <B>until</B>
                i = nb
            <B>loop</B>
                <B>Result</B>.<A HREF="../../elks/managed_pointer.html#f_put_natural_16">put_natural_16</A> (a_string.<A HREF="../../elks/readable_string_general.html#f_code">code</A> (i + 1).<A HREF="../../elks/natural_32_ref.html#f_to_natural_16">to_natural_16</A>, i * 2)
                i := i + 1
            <B>end</B>;
            <B>Result</B>.<A HREF="../../elks/managed_pointer.html#f_put_natural_16">put_natural_16</A> (0, i * 2)
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_pointer_to_multi_byte"><A HREF="../../elks/encoding/encoding_helper.html#f_pointer_to_multi_byte">pointer_to_multi_byte</A> (a_multi_string: <A HREF="../../elks/pointer.html">POINTER</A>; a_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>): <A HREF="../../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> STRING_8 read from </FONT><I>a_multi_string</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_multi_string_not_default: a_multi_string /= <A HREF="../../elks/any.html#f_default_pointer">default_pointer</A>
            a_count_non_negative: a_count &gt;= 0
        <B>local</B>
            i: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_managed_pointer: <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
        <B>do</B>
            <B>create</B> l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_share_from_pointer">share_from_pointer</A> (a_multi_string, a_count)
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_8.html#f_make">make</A> (a_count)
            <B>from</B>
                i := 0
            <B>until</B>
                i &gt;= a_count
            <B>loop</B>
                <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_read_natural_8">read_natural_8</A> (i).<A HREF="../../elks/natural_8_ref.html#f_to_natural_32">to_natural_32</A>)
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_pointer_to_wide_string"><A HREF="../../elks/encoding/encoding_helper.html#f_pointer_to_wide_string">pointer_to_wide_string</A> (a_w_string: <A HREF="../../elks/pointer.html">POINTER</A>; a_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>): <A HREF="../../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> STRING_32 read from </FONT><I>a_w_string</I><FONT COLOR="red"> of </FONT><I>a_count</I><FONT COLOR="red"> bytes.</FONT>
        <B>require</B>
            a_w_string_not_default: a_w_string /= <A HREF="../../elks/any.html#f_default_pointer">default_pointer</A>
            a_count_non_negative: a_count &gt;= 0
        <B>local</B>
            i: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_managed_pointer: <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
            l_size: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_share_from_pointer">share_from_pointer</A> (a_w_string, a_count)
            l_size := (a_count + 1) // 2
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_32.html#f_make">make</A> (l_size)
            <B>from</B>
                i := 0
            <B>until</B>
                i &gt;= l_size
            <B>loop</B>
                <B>if</B> i * 2 &lt;= a_count <B>then</B>
                    <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_read_natural_16">read_natural_16</A> (i * 2).<A HREF="../../elks/natural_16_ref.html#f_to_natural_32">to_natural_32</A>)
                <B>end</B>
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_pointer_to_string_32"><A HREF="../../elks/encoding/encoding_helper.html#f_pointer_to_string_32">pointer_to_string_32</A> (a_w_string: <A HREF="../../elks/pointer.html">POINTER</A>; a_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>): <A HREF="../../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> STRING_32 read from </FONT><I>a_w_string</I><FONT COLOR="red"> of </FONT><I>a_count</I><FONT COLOR="red"> bytes.</FONT>
        <B>require</B>
            a_w_string_not_default: a_w_string /= <A HREF="../../elks/any.html#f_default_pointer">default_pointer</A>
            a_count_non_negative: a_count &gt;= 0
        <B>local</B>
            i: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_managed_pointer: <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
            l_size: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>create</B> l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_share_from_pointer">share_from_pointer</A> (a_w_string, a_count)
            l_size := a_count // 4
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_32.html#f_make">make</A> (l_size)
            <B>from</B>
                i := 0
            <B>until</B>
                i &gt;= l_size
            <B>loop</B>
                <B>if</B> i * 4 &lt;= a_count <B>then</B>
                    <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_read_natural_32">read_natural_32</A> (i * 4))
                <B>end</B>
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_string_32_to_multi_byte"><A HREF="../../elks/encoding/encoding_helper.html#f_string_32_to_multi_byte">string_32_to_multi_byte</A> (a_string: <A HREF="../../elks/string_32.html">STRING_32</A>): <A HREF="../../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Byte stream of </FONT><I>a_string</I><FONT COLOR="red"> in endianness of the current platform.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_code: <A HREF="../../elks/natural_32.html">NATURAL_32</A>
            l_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_is_little_endian: <A HREF="../../elks/boolean.html">BOOLEAN</A>
        <B>do</B>
            l_count := a_string.<A HREF="../../elks/readable_string_32.html#f_count">count</A>
            <B>if</B> l_count &gt; 0 <B>then</B>
                <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_8.html#f_make">make</A> (l_count * 4)
                <B>from</B>
                    i := 1
                    l_is_little_endian := <A HREF="../../elks/encoding/encoding_helper.html#f_is_little_endian">Is_little_endian</A>
                <B>until</B>
                    i &gt; l_count
                <B>loop</B>
                    l_code := a_string.<A HREF="../../elks/string_32.html#f_code">code</A> (i)
                    <B>if</B> l_is_little_endian <B>then</B>
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 255);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 65280 |&gt;&gt; 8);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 16711680 |&gt;&gt; 16);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 4278190080 |&gt;&gt; 24)
                    <B>else</B>
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 4278190080 |&gt;&gt; 24);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 16711680 |&gt;&gt; 16);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 65280 |&gt;&gt; 8);
                        <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 255)
                    <B>end</B>
                    i := i + 1
                <B>end</B>
            <B>else</B>
                <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_general.html#f_make_empty">make_empty</A>
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_string_8_to_wide_string"><A HREF="../../elks/encoding/encoding_helper.html#f_string_8_to_wide_string">string_8_to_wide_string</A> (a_w_string: <A HREF="../../elks/string_8.html">STRING_8</A>): <A HREF="../../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Interpret </FONT><I>a_w_string</I><FONT COLOR="red"> as a sequence of 2-byte characters into a STRING_32</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in endianness of the current platform.</FONT>
        <B>require</B>
            a_w_string_not_void: a_w_string /= <B>Void</B>
        <B>local</B>
            i: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_size, l_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
            l_is_little_endian: <A HREF="../../elks/boolean.html">BOOLEAN</A>
            l_code: <A HREF="../../elks/natural_32.html">NATURAL_32</A>
        <B>do</B>
            l_count := a_w_string.<A HREF="../../elks/readable_string_8.html#f_count">count</A>
            l_size := (l_count + 1) // 2
            l_is_little_endian := <A HREF="../../elks/encoding/encoding_helper.html#f_is_little_endian">Is_little_endian</A>
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_32.html#f_make">make</A> (l_size)
            <B>from</B>
                i := 1
            <B>until</B>
                i &gt; l_count
            <B>loop</B>
                <B>if</B> i + 1 &lt;= l_count <B>then</B>
                    <B>if</B> l_is_little_endian <B>then</B>
                        l_code := a_w_string.<A HREF="../../elks/string_8.html#f_code">code</A> (i) | (a_w_string.<A HREF="../../elks/string_8.html#f_code">code</A> (i + 1) |&lt;&lt; 8)
                    <B>else</B>
                        l_code := (a_w_string.<A HREF="../../elks/string_8.html#f_code">code</A> (i) |&lt;&lt; 8) | a_w_string.<A HREF="../../elks/string_8.html#f_code">code</A> (i + 1)
                    <B>end</B>;
                    <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code)
                <B>end</B>
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_string_16_to_stream"><A HREF="../../elks/encoding/encoding_helper.html#f_string_16_to_stream">string_16_to_stream</A> (a_string: <A HREF="../../elks/string_32.html">STRING_32</A>): <A HREF="../../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> We use </FONT><I>a_string</I><FONT COLOR="red"> as 2 bytes encoding string, the first two bytes are not used.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in the endianness of the current platform.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>local</B>
            l_managed_pointer: <A HREF="../../elks/managed_pointer.html">MANAGED_POINTER</A>
            i, l_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_managed_pointer := <A HREF="../../elks/encoding/encoding_helper.html#f_wide_string_to_pointer">wide_string_to_pointer</A> (a_string)
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_8.html#f_make">make</A> (l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_count">count</A>)
            <B>from</B>
                i := 0
                l_count := l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_count">count</A> - 2
            <B>until</B>
                i = l_count
            <B>loop</B>
                <B>Result</B>.<A HREF="../../elks/string_8.html#f_append_character">append_character</A> (l_managed_pointer.<A HREF="../../elks/managed_pointer.html#f_read_natural_8">read_natural_8</A> (i).<A HREF="../../elks/natural_8.html#f_to_character_8">to_character_8</A>)
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
            valid_count: <B>Result</B>.<A HREF="../../elks/readable_string_8.html#f_count">count</A> = a_string.<A HREF="../../elks/readable_string_32.html#f_count">count</A> * 2
        <B>end</B></A>

    <A NAME="f_string_general_to_stream"><A HREF="../../elks/encoding/encoding_helper.html#f_string_general_to_stream">string_general_to_stream</A> (a_string: <A HREF="../../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Streamize </FONT><I>a_string</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            a_string_not_void: a_string /= <B>Void</B>
        <B>do</B>
            <B>if</B> a_string.<A HREF="../../elks/readable_string_general.html#f_is_string_8">is_string_8</A> <B>then</B>
                <B>Result</B> := a_string.<A HREF="../../elks/readable_string_general.html#f_to_string_8">to_string_8</A>
            <B>else</B>
                <B>Result</B> := <A HREF="../../elks/encoding/encoding_helper.html#f_string_32_to_multi_byte">string_32_to_multi_byte</A> (a_string.<A HREF="../../elks/readable_string_general.html#f_as_string_32">as_string_32</A>)
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Endian</FONT>

    <A NAME="f_string_32_switch_endian"><A HREF="../../elks/encoding/encoding_helper.html#f_string_32_switch_endian">string_32_switch_endian</A> (a_str: <A HREF="../../elks/string_32.html">STRING_32</A>): <A HREF="../../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Switch endian of </FONT><I>a_str</I><FONT COLOR="red"> for both high and low bits.</FONT>
        <B>require</B>
            a_str_not_void: a_str /= <B>Void</B>
        <B>local</B>
            l_code: <A HREF="../../elks/natural_32.html">NATURAL_32</A>
            i, l_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_count := a_str.<A HREF="../../elks/readable_string_32.html#f_count">count</A>
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_32.html#f_make">make</A> (l_count)
            <B>from</B>
                i := 1
            <B>until</B>
                i &gt; l_count
            <B>loop</B>
                l_code := a_str.<A HREF="../../elks/string_32.html#f_code">code</A> (i);
                <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 255 |&lt;&lt; 24 &#38; 4278190080 + l_code &#38; 65280 |&lt;&lt; 8 + l_code &#38; 16711680 |&gt;&gt; 8 + l_code &#38; 4278190080 |&gt;&gt; 24 &#38; 255)
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_string_16_switch_endian"><A HREF="../../elks/encoding/encoding_helper.html#f_string_16_switch_endian">string_16_switch_endian</A> (a_str: <A HREF="../../elks/string_32.html">STRING_32</A>): <A HREF="../../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Switch endian of </FONT><I>a_str</I><FONT COLOR="red"> for low bits.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> High bits are cleaned.</FONT>
        <B>require</B>
            a_str_not_void: a_str /= <B>Void</B>
        <B>local</B>
            l_code: <A HREF="../../elks/natural_32.html">NATURAL_32</A>
            i, l_count: <A HREF="../../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            l_count := a_str.<A HREF="../../elks/readable_string_32.html#f_count">count</A>
            <B>create</B> <B>Result</B>.<A HREF="../../elks/readable_string_32.html#f_make">make</A> (l_count)
            <B>from</B>
                i := 1
            <B>until</B>
                i &gt; l_count
            <B>loop</B>
                l_code := a_str.<A HREF="../../elks/string_32.html#f_code">code</A> (i);
                <B>Result</B>.<A HREF="../../elks/string_general.html#f_append_code">append_code</A> (l_code &#38; 255 |&lt;&lt; 8 &#38; 65280 + l_code &#38; 65280 |&gt;&gt; 8 &#38; 255)
                i := i + 1
            <B>end</B>
        <B>ensure</B>
            instance_free: <B>class</B>
            result_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>

    <A NAME="f_is_little_endian"><A HREF="../../elks/encoding/encoding_helper.html#f_is_little_endian">Is_little_endian</A>: <A HREF="../../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is this system little endian?</FONT>
        <B>once</B>
            <B>Result</B> := {<A HREF="../../elks/platform.html">PLATFORM</A>}.<A HREF="../../elks/platform.html#f_is_little_endian">is_little_endian</A>
        <B>ensure</B>
            instance_free: <B>class</B>
        <B>end</B></A>
    
<B>note</B>
    library: "Encoding: Library of reusable components for Eiffel."
    copyright: "Copyright (c) 1984-2020, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../../elks/encoding/encoding_helper.html">ENCODING_HELPER</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../../class_list.html">Classes</A></TD><TD><A HREF="../../cluster_list.html">Clusters</A></TD><TD><A HREF="../../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="encoding_helper_chart.html">Chart</A></TD><TD><A HREF="encoding_helper_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

