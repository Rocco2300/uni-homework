<HTML><HEAD>
<meta name="description" content="Directories, in the Unix sense, with creation and exploration features"/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="copyright" content="Copyright (c) 1984-2017, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>directory Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="directory_chart.html">Chart</A></TD><TD><A HREF="directory_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "Directories, in the Unix sense, with creation and exploration features"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    legal: "See notice at end of class."
    date: "$Date: 2017-03-23 19:18:26 +0000 (Thu, 23 Mar 2017) $"
    revision: "$Revision: 100033 $"

<B>class</B> 
    <A HREF="../elks/directory.html">DIRECTORY</A>

<B>inherit</B>
    <A HREF="../elks/disposable.html">DISPOSABLE</A>

    <A HREF="../elks/native_string_handler.html">NATIVE_STRING_HANDLER</A>

<B>create</B> 
    <A HREF="../elks/directory.html#f_make">make</A>,
    <A HREF="../elks/directory.html#f_make_with_path">make_with_path</A>,
    <A HREF="../elks/directory.html#f_make_with_name">make_with_name</A>,
    <A HREF="../elks/directory.html#f_make_open_read">make_open_read</A>

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_make"><A HREF="../elks/directory.html#f_make">make</A> (dn: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create directory object for directory</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of name </FONT><I>dn</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            string_exists: dn /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/directory.html#f_make_with_name">make_with_name</A> (dn)
        <B>ensure</B>
            name_set: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = dn
        <B>end</B></A>

    <A NAME="f_make_with_name"><A HREF="../elks/directory.html#f_make_with_name">make_with_name</A> (dn: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create directory object for directory</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of name </FONT><I>dn</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            string_exists: dn /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/directory.html#f_set_name">set_name</A> (dn)
            <A HREF="../elks/directory.html#f_mode">mode</A> := <A HREF="../elks/directory.html#f_close_directory">Close_directory</A>
        <B>ensure</B>
            name_set: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = dn
        <B>end</B></A>

    <A NAME="f_make_with_path"><A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (a_path: <A HREF="../elks/path.html">PATH</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create file object with </FONT><I>a_path</I><FONT COLOR="red"> as path.</FONT>
        <B>require</B>
            a_path_attached: a_path /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/directory.html#f_make">make</A> (a_path.<A HREF="../elks/path.html#f_name">name</A>)
        <B>end</B></A>

    <A NAME="f_make_open_read"><A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (dn: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create directory object for directory</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of name </FONT><I>dn</I><FONT COLOR="red"> and open it for reading.</FONT>
        <B>require</B>
            string_exists: dn /= <B>Void</B>
        <B>do</B>
            <A HREF="../elks/directory.html#f_make">make</A> (dn)
            <A HREF="../elks/directory.html#f_open_read">open_read</A>
        <B>ensure</B>
            name_set: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = dn
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Creation</FONT>

    <A NAME="f_create_dir"><A HREF="../elks/directory.html#f_create_dir">create_dir</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create a physical directory.</FONT>
        <B>require</B>
            physical_not_exists: <B>not</B> <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_file_mkdir">file_mkdir</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_recursive_create_dir"><A HREF="../elks/directory.html#f_recursive_create_dir">recursive_create_dir</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Create the directory recursively.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Ex: if /temp/ exists but not /temp/test, then trying</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">  to create /temp/test/toto will create /temp/test</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red">  and then /temp/test/toto.</FONT>
        <B>local</B>
            l_directory: <A HREF="../elks/directory.html">DIRECTORY</A>
            l_directories_to_build: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/path.html">PATH</A>]
            l_path: <A HREF="../elks/path.html">PATH</A>
            l_entry: <B>detachable</B> <A HREF="../elks/path.html">PATH</A>
            l_io_exception: <A HREF="../ise/io_failure.html">IO_FAILURE</A>
        <B>do</B>
            l_path := <A HREF="../elks/directory.html#f_path">path</A>.<A HREF="../elks/path.html#f_canonical_path">canonical_path</A>
            <B>create</B> l_directory.<A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (l_path)
            <B>if</B> <B>not</B> l_directory.<A HREF="../elks/directory.html#f_exists">exists</A> <B>then</B>
                <B>from</B>
                    <B>create</B> l_directories_to_build.<A HREF="../elks/arrayed_list.html#f_make">make</A> (10)
                    l_entry := l_path.<A HREF="../elks/path.html#f_entry">entry</A>
                <B>until</B>
                    l_directory.<A HREF="../elks/directory.html#f_exists">exists</A> <B>or</B> l_entry = <B>Void</B>
                <B>loop</B>
                    l_directories_to_build.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (l_path)
                    l_path := l_path.<A HREF="../elks/path.html#f_parent">parent</A>
                    l_entry := l_path.<A HREF="../elks/path.html#f_entry">entry</A>;
                    l_directory.<A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (l_path)
                <B>end</B>
                <B>from</B>
                    l_directories_to_build.<A HREF="../elks/arrayed_list.html#f_finish">finish</A>
                <B>until</B>
                    l_directories_to_build.<A HREF="../elks/list.html#f_before">before</A>
                <B>loop</B>
                    l_path := l_directories_to_build.<A HREF="../elks/arrayed_list.html#f_item">item</A>;
                    l_directories_to_build.<A HREF="../elks/arrayed_list.html#f_back">back</A>;
                    l_directory.<A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (l_path);
                    l_directory.<A HREF="../elks/directory.html#f_create_dir">create_dir</A>
                    <B>if</B> <B>not</B> l_directory.<A HREF="../elks/directory.html#f_exists">exists</A> <B>then</B>
                        <B>create</B> l_io_exception;
                        l_io_exception.<A HREF="../elks/exception.html#f_set_description">set_description</A> ({<A HREF="../elks/string_32.html">STRING_32</A>} "Cannot create: " + l_path.<A HREF="../elks/path.html#f_name">name</A>);
                        l_io_exception.<A HREF="../elks/exception.html#f_raise">raise</A>
                    <B>end</B>
                <B>end</B>
            <B>end</B>
        <B>ensure</B>
            physical_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_path"><A HREF="../elks/directory.html#f_path">path</A>: <A HREF="../elks/path.html">PATH</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Associated path of Current.</FONT>
        <B>do</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>ensure</B>
            entry_not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_readentry"><A HREF="../elks/directory.html#f_readentry">readentry</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Read next directory entry</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> make result available in </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_lastentry">lastentry</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Make result Void if all entries have been read.</FONT>
        <B>require</B>
            is_opened: <B>not</B> <A HREF="../elks/directory.html#f_is_closed">is_closed</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A> := <A HREF="../elks/directory.html#f_eif_dir_next">eif_dir_next</A> (<A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A>)
            <B>if</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A> = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A> <B>then</B>
                <A HREF="../elks/directory.html#f_lastentry">lastentry</A> := <B>Void</B>
            <B>else</B>
                <A HREF="../elks/directory.html#f_lastentry">lastentry</A> := <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_8">pointer_to_file_name_8</A> (<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_name"><A HREF="../elks/directory.html#f_name">name</A>: <A HREF="../elks/string_8.html">STRING_8</A>
        <B>obsolete</B> "Use `path' to ensure you can retrieve all kind of names. [2017-05-31]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> File name as a STRING_8 instance. The value might be truncated</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> from the original name used to create the current FILE instance.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_internal_name">internal_name</A>.<A HREF="../elks/readable_string_general.html#f_as_string_8">as_string_8</A>
        <B>ensure then</B>
            name_not_empty: <B>not</B> <B>Result</B>.<A HREF="../elks/finite.html#f_is_empty">is_empty</A>
        <B>end</B></A>

    <A NAME="f_has_entry"><A HREF="../elks/directory.html#f_has_entry">has_entry</A> (entry_name: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Has directory the entry </FONT><I>entry_name</I><FONT COLOR="red">?</FONT>
        <B>require</B>
            string_exists: entry_name /= <B>Void</B>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            e: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>until</B>
                <B>Result</B> <B>or</B> e = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>if</B> <B>attached</B> {<A HREF="../elks/readable_string_8.html">READABLE_STRING_8</A>} entry_name <B>then</B>
                    <B>Result</B> := entry_name.<A HREF="../elks/readable_string_general.html#f_same_string">same_string</A> (<A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_8">pointer_to_file_name_8</A> (e))
                <B>elseif</B> <B>attached</B> <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_32">pointer_to_file_name_32</A> (e) <B>as</B> l_str <B>then</B>
                    <B>Result</B> := entry_name.<A HREF="../elks/readable_string_general.html#f_same_string">same_string</A> (l_str)
                <B>end</B>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>

    <A NAME="f_open_read"><A HREF="../elks/directory.html#f_open_read">open_read</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Open directory for reading.</FONT>
        <B>do</B>
            <A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A> := <A HREF="../elks/directory.html#f_dir_open">dir_open</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
            <A HREF="../elks/directory.html#f_mode">mode</A> := <A HREF="../elks/directory.html#f_read_directory">Read_directory</A>
        <B>end</B></A>

    <A NAME="f_close"><A HREF="../elks/directory.html#f_close">close</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Close directory.</FONT>
        <B>require</B>
            is_open: <B>not</B> <A HREF="../elks/directory.html#f_is_closed">is_closed</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_dir_close">dir_close</A> (<A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A>)
            <A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A> := <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <A HREF="../elks/directory.html#f_mode">mode</A> := <A HREF="../elks/directory.html#f_close_directory">Close_directory</A>
        <B>end</B></A>

    <A NAME="f_start"><A HREF="../elks/directory.html#f_start">start</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Go to first entry of directory.</FONT>
        <B>require</B>
            is_opened: <B>not</B> <A HREF="../elks/directory.html#f_is_closed">is_closed</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A> := <A HREF="../elks/directory.html#f_dir_rewind">dir_rewind</A> (<A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A>, <A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_change_name"><A HREF="../elks/directory.html#f_change_name">change_name</A> (new_name: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Change directory name to </FONT><I>new_name</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            new_name_not_void: new_name /= <B>Void</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>local</B>
            l_ptr: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
        <B>do</B>
            l_ptr := <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_file_name_to_pointer">file_name_to_pointer</A> (new_name, <B>Void</B>)
            <A HREF="../elks/directory.html#f_eif_dir_rename">eif_dir_rename</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>, l_ptr.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
            <A HREF="../elks/directory.html#f_set_name">set_name</A> (new_name)
        <B>ensure</B>
            name_changed: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = new_name
        <B>end</B></A>

    <A NAME="f_rename_path"><A HREF="../elks/directory.html#f_rename_path">rename_path</A> (new_name: <A HREF="../elks/path.html">PATH</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Change directory name to </FONT><I>new_name</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            new_name_not_void: new_name /= <B>Void</B>
            new_name_not_empty: <B>not</B> new_name.<A HREF="../elks/path.html#f_is_empty">is_empty</A>
            file_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>local</B>
            l_ptr: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
        <B>do</B>
            l_ptr := new_name.<A HREF="../elks/path.html#f_to_pointer">to_pointer</A>
            <A HREF="../elks/directory.html#f_eif_dir_rename">eif_dir_rename</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>, l_ptr.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
            <A HREF="../elks/directory.html#f_set_name">set_name</A> (new_name.<A HREF="../elks/path.html#f_name">name</A>)
        <B>ensure</B>
            name_changed: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = new_name.<A HREF="../elks/path.html#f_name">name</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_count"><A HREF="../elks/directory.html#f_count">count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of entries in directory.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
            <B>until</B>
                dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A> = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>Result</B> := <B>Result</B> + 1;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Conversion</FONT>

    <A NAME="f_entries"><A HREF="../elks/directory.html#f_entries">entries</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/path.html">PATH</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Entries (i.e. just the file or directory name) of current directory,</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in sequential format, in a platform specific order.</FONT>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            e: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (16)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>until</B>
                e = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A> (e) <B>end</B>);
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>

    <A NAME="f_resolved_entries"><A HREF="../elks/directory.html#f_resolved_entries">resolved_entries</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/path.html">PATH</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Entries of current directory resolved in the context of current directory (i.e. the path</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of the current directory appended with the entry) in sequential format, in a platform specific</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> order.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Compared to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_entries">entries</A><FONT COLOR="red">`</FONT><FONT COLOR="red">, it removes the need for callers to build the full path of the entry</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> using </FONT><I>Current</I><FONT COLOR="red">.</FONT>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            e: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            l_path: <B>like</B> <A HREF="../elks/directory.html#f_path">path</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (16)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
                l_path := <A HREF="../elks/directory.html#f_path">path</A>
            <B>until</B>
                e = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (l_path.<A HREF="../elks/path.html#f_extended_path">extended_path</A> (<B>create</B> {<A HREF="../elks/path.html">PATH</A>}.<A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A> (e) <B>end</B>));
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>

    <A NAME="f_linear_representation"><A HREF="../elks/directory.html#f_linear_representation">linear_representation</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/string_8.html">STRING_8</A>]
        <B>obsolete</B> "Use `entries' instead if your application is using Unicode file names. [2017-05-31]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The entries, in sequential format.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_entries">entries</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> or </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_linear_representation_32">linear_representation_32</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> to get a readable version</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> of the Unicode entries.</FONT>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            e: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (16)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>until</B>
                e = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_8">pointer_to_file_name_8</A> (e));
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>

    <A NAME="f_linear_representation_32"><A HREF="../elks/directory.html#f_linear_representation_32">linear_representation_32</A>: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/string_32.html">STRING_32</A>]
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The entries, in sequential format.</FONT>
        <B>local</B>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            e: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            l_path: <A HREF="../elks/path.html">PATH</A>
        <B>do</B>
            <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
            <B>create</B> <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_make">make</A> (16)
            <B>from</B>
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>until</B>
                e = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A>
            <B>loop</B>
                <B>create</B> l_path.<A HREF="../elks/path.html#f_make_from_pointer">make_from_pointer</A> (e);
                <B>Result</B>.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<B>create</B> {<A HREF="../elks/string_32.html">STRING_32</A>}.<A HREF="../elks/readable_string_32.html#f_make_from_string">make_from_string</A> (l_path.<A HREF="../elks/path.html#f_name">name</A>) <B>end</B>);
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                e := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_last_entry_32"><A HREF="../elks/directory.html#f_last_entry_32">last_entry_32</A>: <B>detachable</B> <A HREF="../elks/string_32.html">STRING_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Last Unicode entry read by </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_readentry">readentry</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> if any.</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A> /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_32">pointer_to_file_name_32</A> (<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_last_entry_8"><A HREF="../elks/directory.html#f_last_entry_8">last_entry_8</A>: <B>detachable</B> <A HREF="../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Raw byte sequence of the last found entry if this entry cannot be</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> expressed with Unicode characters. This is useful</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> when handling a file that is not a valid UTF-8 sequence on Unix.</FONT>
        <B>do</B>
            <B>if</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A> /= <A HREF="../elks/any.html#f_default_pointer">default_pointer</A> <B>then</B>
                <B>Result</B> := <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_pointer_to_file_name_8">pointer_to_file_name_8</A> (<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_lastentry"><A HREF="../elks/directory.html#f_lastentry">lastentry</A>: <B>detachable</B> <A HREF="../elks/string_8.html">STRING_8</A>
        <B>obsolete</B> "Use `last_entry_32' for Unicode file names, or `last_entry_8' otherwise. [2017-05-31]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Last entry read by </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_readentry">readentry</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>attribute</B>
        <B>end</B></A>

    <A NAME="f_is_closed"><A HREF="../elks/directory.html#f_is_closed">is_closed</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is current directory closed?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_mode">mode</A> = <A HREF="../elks/directory.html#f_close_directory">Close_directory</A>
        <B>end</B></A>

    <A NAME="f_is_empty"><A HREF="../elks/directory.html#f_is_empty">is_empty</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is directory empty?</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_count">count</A> = 2
        <B>end</B></A>

    <A NAME="f_exists"><A HREF="../elks/directory.html#f_exists">exists</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does the directory exist?</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_eif_dir_exists">eif_dir_exists</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_is_readable"><A HREF="../elks/directory.html#f_is_readable">is_readable</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the directory readable?</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_eif_dir_is_readable">eif_dir_is_readable</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_is_executable"><A HREF="../elks/directory.html#f_is_executable">is_executable</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the directory executable?</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_eif_dir_is_executable">eif_dir_is_executable</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_is_writable"><A HREF="../elks/directory.html#f_is_writable">is_writable</A>: <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the directory writable?</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/directory.html#f_eif_dir_is_writable">eif_dir_is_writable</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Removal</FONT>

    <A NAME="f_delete"><A HREF="../elks/directory.html#f_delete">delete</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete directory if empty.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
            empty_directory: <A HREF="../elks/directory.html#f_is_empty">is_empty</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_eif_dir_delete">eif_dir_delete</A> (<A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>.<A HREF="../elks/managed_pointer.html#f_item">item</A>)
        <B>end</B></A>

    <A NAME="f_delete_content"><A HREF="../elks/directory.html#f_delete_content">delete_content</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete all files located in current directory and its</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> subdirectories.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_delete_content_with_action">delete_content_with_action</A> (<B>Void</B>, <B>Void</B>, 0)
        <B>end</B></A>

    <A NAME="f_recursive_delete"><A HREF="../elks/directory.html#f_recursive_delete">recursive_delete</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete directory, its files and its subdirectories.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>do</B>
            <A HREF="../elks/directory.html#f_delete_content">delete_content</A>
            <B>if</B> <A HREF="../elks/directory.html#f_is_empty">is_empty</A> <B>then</B>
                <A HREF="../elks/directory.html#f_delete">delete</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_delete_content_with_action"><A HREF="../elks/directory.html#f_delete_content_with_action">delete_content_with_action</A> (action: <B>detachable</B> <A HREF="../elks/procedure.html">PROCEDURE</A> [<A HREF="../elks/list.html">LIST</A> [<A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>]]; is_cancel_requested: <B>detachable</B> <A HREF="../elks/function.html">FUNCTION</A> [<A HREF="../elks/boolean.html">BOOLEAN</A>]; file_number: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete all files located in current directory and its</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> subdirectories.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>action</I><FONT COLOR="red"> is called each time at most </FONT><I>file_number</I><FONT COLOR="red"> files has</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> been deleted and before the function exits. If </FONT><I>a_file_number</I>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> is non-positive, </FONT><I>action</I><FONT COLOR="red"> is not called.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>action</I><FONT COLOR="red"> may be set to Void if you don't need it.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Same for </FONT><I>is_cancel_requested</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Make it return </FONT><I>True</I><FONT COLOR="red"> to cancel the operation.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>is_cancel_requested</I><FONT COLOR="red"> may be set to Void if you don't need it.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
            valid_file_number: file_number &gt;= 0
        <B>local</B>
            l_file_name: <A HREF="../elks/path.html">PATH</A>
            file: <A HREF="../elks/raw_file.html">RAW_FILE</A>
            l_info: <B>like</B> <A HREF="../elks/directory.html#f_file_info">File_info</A>
            dir: <A HREF="../elks/directory.html">DIRECTORY</A>
            dir_temp: <A HREF="../elks/directory.html">DIRECTORY</A>
            l_last_entry_pointer: <B>like</B> <A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            l_name: <A HREF="../elks/readable_string_32.html">READABLE_STRING_32</A>
            file_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            deleted_files: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/readable_string_32.html">READABLE_STRING_32</A>]
            requested_cancel: <A HREF="../elks/boolean.html">BOOLEAN</A>
        <B>do</B>
            <B>create</B> deleted_files.<A HREF="../elks/arrayed_list.html#f_make">make</A> (file_number.<A HREF="../elks/comparable.html#f_min">min</A> (1024))
            <B>from</B>
                l_info := <A HREF="../elks/directory.html#f_file_info">File_info</A>;
                l_info.<A HREF="../elks/file_info.html#f_set_is_following_symlinks">set_is_following_symlinks</A> (<B>False</B>)
                <B>create</B> dir_temp.<A HREF="../elks/directory.html#f_make_open_read">make_open_read</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>);
                dir_temp.<A HREF="../elks/directory.html#f_start">start</A>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                l_last_entry_pointer := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>until</B>
                l_last_entry_pointer = <A HREF="../elks/any.html#f_default_pointer">default_pointer</A> <B>or</B> requested_cancel
            <B>loop</B>
                l_name := l_info.<A HREF="../elks/file_info.html#f_pointer_to_file_name_32">pointer_to_file_name_32</A> (l_last_entry_pointer)
                <B>if</B> <B>not</B> l_name.<A HREF="../elks/readable_string_general.html#f_same_string">same_string_general</A> (<A HREF="../elks/directory.html#f_current_directory_string">Current_directory_string</A>) <B>and</B> <B>not</B> l_name.<A HREF="../elks/readable_string_general.html#f_same_string">same_string_general</A> (<A HREF="../elks/directory.html#f_parent_directory_string">Parent_directory_string</A>) <B>then</B>
                    l_file_name := <A HREF="../elks/directory.html#f_path">path</A>.<A HREF="../elks/path.html#f_extended">extended</A> (l_name);
                    l_info.<A HREF="../elks/file_info.html#f_update">update</A> (l_file_name.<A HREF="../elks/path.html#f_name">name</A>)
                    <B>if</B> l_info.<A HREF="../elks/file_info.html#f_exists">exists</A> <B>then</B>
                        <B>if</B> <B>not</B> l_info.<A HREF="../elks/file_info.html#f_is_symlink">is_symlink</A> <B>and then</B> l_info.<A HREF="../elks/file_info.html#f_is_directory">is_directory</A> <B>then</B>
                            <B>if</B> dir /= <B>Void</B> <B>then</B>
                                dir.<A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (l_file_name)
                            <B>else</B>
                                <B>create</B> dir.<A HREF="../elks/directory.html#f_make_with_path">make_with_path</A> (l_file_name)
                            <B>end</B>;
                            dir.<A HREF="../elks/directory.html#f_recursive_delete_with_action">recursive_delete_with_action</A> (action, is_cancel_requested, file_number)
                        <B>elseif</B> l_info.<A HREF="../elks/file_info.html#f_is_writable">is_writable</A> <B>then</B>
                            <B>if</B> file /= <B>Void</B> <B>then</B>
                                file.<A HREF="../elks/file.html#f_reset_path">reset_path</A> (l_file_name)
                            <B>else</B>
                                <B>create</B> file.<A HREF="../elks/file.html#f_make_with_path">make_with_path</A> (l_file_name)
                            <B>end</B>;
                            file.<A HREF="../elks/file.html#f_delete">delete</A>;
                            deleted_files.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (l_file_name.<A HREF="../elks/path.html#f_name">name</A>)
                            file_count := file_count + 1
                        <B>end</B>
                        <B>if</B> file_number &gt; 0 <B>and</B> file_count &gt;= file_number <B>then</B>
                            <B>if</B> action /= <B>Void</B> <B>then</B>
                                action (deleted_files)
                            <B>end</B>
                            <B>if</B> is_cancel_requested /= <B>Void</B> <B>then</B>
                                requested_cancel := is_cancel_requested (<B>Void</B>)
                            <B>end</B>;
                            deleted_files.<A HREF="../elks/arrayed_list.html#f_wipe_out">wipe_out</A>
                            file_count := 0
                        <B>end</B>
                    <B>end</B>
                <B>end</B>;
                dir_temp.<A HREF="../elks/directory.html#f_readentry">readentry</A>
                l_last_entry_pointer := dir_temp.<A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>
            <B>end</B>;
            dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
            <B>if</B> file_number &gt; 0 <B>and</B> file_count &gt; 0 <B>and</B> action /= <B>Void</B> <B>then</B>
                action (deleted_files)
            <B>end</B>
        <B>rescue</B>
            <B>if</B> dir_temp /= <B>Void</B> <B>and then</B> <B>not</B> dir_temp.<A HREF="../elks/directory.html#f_is_closed">is_closed</A> <B>then</B>
                dir_temp.<A HREF="../elks/directory.html#f_close">close</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_recursive_delete_with_action"><A HREF="../elks/directory.html#f_recursive_delete_with_action">recursive_delete_with_action</A> (action: <B>detachable</B> <A HREF="../elks/procedure.html">PROCEDURE</A> [<A HREF="../elks/list.html">LIST</A> [<A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>]]; is_cancel_requested: <B>detachable</B> <A HREF="../elks/function.html">FUNCTION</A> [<A HREF="../elks/boolean.html">BOOLEAN</A>]; file_number: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete directory, its files and its subdirectories.</FONT>
            <FONT COLOR="red">--</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> </FONT><I>action</I><FONT COLOR="red"> is called each time at most </FONT><I>file_number</I><FONT COLOR="red"> files has</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> been deleted and before the function exits. If </FONT><I>a_file_number</I>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> is non-positive, </FONT><I>action</I><FONT COLOR="red"> is not called.</FONT>
        <B>require</B>
            directory_exists: <A HREF="../elks/directory.html#f_exists">exists</A>
        <B>local</B>
            deleted_files: <A HREF="../elks/arrayed_list.html">ARRAYED_LIST</A> [<A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>]
        <B>do</B>
            <A HREF="../elks/directory.html#f_delete_content_with_action">delete_content_with_action</A> (action, is_cancel_requested, file_number)
            <B>if</B> <B>attached</B> is_cancel_requested implies not is_cancel_requested (<B>Void</B>) <B>then</B>
                <A HREF="../elks/directory.html#f_delete">delete</A>
                <B>if</B> file_number &gt; 0 <B>and</B> action /= <B>Void</B> <B>then</B>
                    <B>create</B> deleted_files.<A HREF="../elks/arrayed_list.html#f_make">make</A> (1);
                    deleted_files.<A HREF="../elks/arrayed_list.html#f_extend">extend</A> (<A HREF="../elks/directory.html#f_internal_name">internal_name</A>)
                    action (deleted_files)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_dispose"><A HREF="../elks/directory.html#f_dispose">dispose</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Ensure this medium is closed when garbage collected.</FONT>
        <B>do</B>
            <B>if</B> <B>not</B> <A HREF="../elks/directory.html#f_is_closed">is_closed</A> <B>then</B>
                <A HREF="../elks/directory.html#f_close">close</A>
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/directory.html">DIRECTORY</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_directory_pointer"><A HREF="../elks/directory.html#f_directory_pointer">directory_pointer</A>: <A HREF="../elks/pointer.html">POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Directory pointer as required in C</FONT>

    <A NAME="f_last_entry_pointer"><A HREF="../elks/directory.html#f_last_entry_pointer">last_entry_pointer</A>: <A HREF="../elks/pointer.html">POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Pointer to the underlying C memory representing the last directory entry.</FONT>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_set_name"><A HREF="../elks/directory.html#f_set_name">set_name</A> (a_name: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_name">name</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> with </FONT><I>a_name</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <A HREF="../elks/directory.html#f_internal_name">internal_name</A> := a_name
            <A HREF="../elks/directory.html#f_internal_detachable_name_pointer">internal_detachable_name_pointer</A> := <A HREF="../elks/directory.html#f_file_info">File_info</A>.<A HREF="../elks/file_info.html#f_file_name_to_pointer">file_name_to_pointer</A> (a_name, <A HREF="../elks/directory.html#f_internal_detachable_name_pointer">internal_detachable_name_pointer</A>)
        <B>ensure</B>
            name_set: <A HREF="../elks/directory.html#f_internal_name">internal_name</A> = a_name
        <B>end</B></A>

    <A NAME="f_internal_name"><A HREF="../elks/directory.html#f_internal_name">internal_name</A>: <A HREF="../elks/readable_string_general.html">READABLE_STRING_GENERAL</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Store the name of the file as it was given to us by the user</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> to avoid conversion on storing as it is not necessary.</FONT>

    <A NAME="f_internal_name_pointer"><A HREF="../elks/directory.html#f_internal_name_pointer">internal_name_pointer</A>: <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> File system specific encoding of </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/directory.html#f_internal_name">internal_name</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Typically a UTF-16 sequence on Windows, a UTF-8 sequence on Unix.</FONT>
        <B>do</B>
            <B>if</B> <B>attached</B> <A HREF="../elks/directory.html#f_internal_detachable_name_pointer">internal_detachable_name_pointer</A> <B>as</B> l_ptr <B>then</B>
                <B>Result</B> := l_ptr
            <B>else</B>
                <B>check</B>
                    internal_name_pointer_set: <B>False</B>
                <B>then</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_internal_detachable_name_pointer"><A HREF="../elks/directory.html#f_internal_detachable_name_pointer">internal_detachable_name_pointer</A>: <B>detachable</B> <A HREF="../elks/managed_pointer.html">MANAGED_POINTER</A>
        <B>note</B>
            option: stable
        <B>attribute</B>
        <B>end</B></A>

    <A NAME="f_mode"><A HREF="../elks/directory.html#f_mode">mode</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status mode of the directory.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Possible values are the following:</FONT>

    <A NAME="f_close_directory"><A HREF="../elks/directory.html#f_close_directory">Close_directory</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 1</A>

    <A NAME="f_read_directory"><A HREF="../elks/directory.html#f_read_directory">Read_directory</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A> = 2</A>

    <A NAME="f_current_directory_string"><A HREF="../elks/directory.html#f_current_directory_string">Current_directory_string</A>: <A HREF="../elks/string_8.html">STRING_8</A> = "."</A>

    <A NAME="f_parent_directory_string"><A HREF="../elks/directory.html#f_parent_directory_string">Parent_directory_string</A>: <A HREF="../elks/string_8.html">STRING_8</A> = ".."</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Constants to represent current (".") and parent ("..") directory.</FONT>

    <A NAME="f_directory_separator_string"><A HREF="../elks/directory.html#f_directory_separator_string">Directory_separator_string</A>: <A HREF="../elks/string_8.html">STRING_8</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Constant representing the directory separator</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/readable_string_8.html#f_make">make</A> (1);
            <B>Result</B>.<A HREF="../elks/string_8.html#f_append_character">append_character</A> (<A HREF="../elks/any.html#f_operating_environment">Operating_environment</A>.<A HREF="../elks/operating_environment.html#f_directory_separator">Directory_separator</A>)
        <B>end</B></A>

    <A NAME="f_file_info"><A HREF="../elks/directory.html#f_file_info">File_info</A>: <A HREF="../elks/file_info.html">FILE_INFO</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> To avoid creating objects when querying for files.</FONT>
        <B>once</B>
            <B>create</B> <B>Result</B>.<A HREF="../elks/file_info.html#f_make">make</A>
        <B>end</B></A>

    <A NAME="f_file_mkdir"><A HREF="../elks/directory.html#f_file_mkdir">file_mkdir</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Make directory </FONT><I>dir_name</I><FONT COLOR="red">.</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME) use %"eif_file.h%""
        <B>alias</B>
            "eif_file_mkdir"
        <B>end</B></A>

    <A NAME="f_dir_open"><A HREF="../elks/directory.html#f_dir_open">dir_open</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/pointer.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Open the directory </FONT><I>dir_name</I><FONT COLOR="red">.</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME): EIF_POINTER use %"eif_dir.h%""
        <B>alias</B>
            "eif_dir_open"
        <B>end</B></A>

    <A NAME="f_dir_rewind"><A HREF="../elks/directory.html#f_dir_rewind">dir_rewind</A> (dir_ptr: <A HREF="../elks/pointer.html">POINTER</A>; dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/pointer.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Rewind the directory </FONT><I>dir_ptr</I><FONT COLOR="red"> with name </FONT><I>a_name</I><FONT COLOR="red"> and return a new directory traversal pointer.</FONT>
        <B>external</B>
            "C signature (EIF_POINTER, EIF_FILENAME): EIF_POINTER use %"eif_dir.h%""
        <B>alias</B>
            "eif_dir_rewind"
        <B>end</B></A>

    <A NAME="f_dir_close"><A HREF="../elks/directory.html#f_dir_close">dir_close</A> (dir_ptr: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Close the directory </FONT><I>dir_ptr</I><FONT COLOR="red">.</FONT>
        <B>external</B>
            "C use %"eif_dir.h%""
        <B>alias</B>
            "eif_dir_close"
        <B>end</B></A>

    <A NAME="f_eif_dir_next"><A HREF="../elks/directory.html#f_eif_dir_next">eif_dir_next</A> (dir_ptr: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/pointer.html">POINTER</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Return pointer to the next entry in the current iteration.</FONT>
        <B>external</B>
            "C use %"eif_dir.h%""
        <B>end</B></A>

    <A NAME="f_eif_dir_delete"><A HREF="../elks/directory.html#f_eif_dir_delete">eif_dir_delete</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Delete the directory </FONT><I>dir_name</I><FONT COLOR="red">.</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME) use %"eif_file.h%""
        <B>alias</B>
            "eif_file_unlink"
        <B>end</B></A>

    <A NAME="f_eif_dir_exists"><A HREF="../elks/directory.html#f_eif_dir_exists">eif_dir_exists</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does the directory </FONT><I>dir_name</I><FONT COLOR="red"> exist?</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME): EIF_BOOLEAN use %"eif_dir.h%""
        <B>end</B></A>

    <A NAME="f_eif_dir_is_readable"><A HREF="../elks/directory.html#f_eif_dir_is_readable">eif_dir_is_readable</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>dir_name</I><FONT COLOR="red"> readable?</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME): EIF_BOOLEAN use %"eif_dir.h%""
        <B>end</B></A>

    <A NAME="f_eif_dir_is_executable"><A HREF="../elks/directory.html#f_eif_dir_is_executable">eif_dir_is_executable</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>dir_name</I><FONT COLOR="red"> executable?</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME): EIF_BOOLEAN use %"eif_dir.h%""
        <B>end</B></A>

    <A NAME="f_eif_dir_is_writable"><A HREF="../elks/directory.html#f_eif_dir_is_writable">eif_dir_is_writable</A> (dir_name: <A HREF="../elks/pointer.html">POINTER</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is </FONT><I>dir_name</I><FONT COLOR="red"> writable?</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME): EIF_BOOLEAN use %"eif_dir.h%""
        <B>end</B></A>

    <A NAME="f_eif_dir_rename"><A HREF="../elks/directory.html#f_eif_dir_rename">eif_dir_rename</A> (old_name, new_name: <A HREF="../elks/pointer.html">POINTER</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Change directory name from </FONT><I>old_name</I><FONT COLOR="red"> to </FONT><I>new_name</I><FONT COLOR="red">.</FONT>
        <B>external</B>
            "C signature (EIF_FILENAME, EIF_FILENAME) use %"eif_file.h%""
        <B>alias</B>
            "eif_file_rename"
        <B>end</B></A>
    
<B>invariant</B>
    name_attached: <B>attached</B> <A HREF="../elks/directory.html#f_internal_name">internal_name</A>

<B>note</B>
    copyright: "Copyright (c) 1984-2017, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/directory.html">DIRECTORY</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="directory_chart.html">Chart</A></TD><TD><A HREF="directory_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

