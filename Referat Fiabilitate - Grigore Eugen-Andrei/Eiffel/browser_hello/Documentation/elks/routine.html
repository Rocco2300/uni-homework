<HTML><HEAD>
<meta name="description" content="Objects representing delayed calls to a routine, with some operands possibly still open"/>
<meta name="library" content="Free implementation of ELKS library"/>
<meta name="legal" content="See notice at end of class."/>
<meta name="keywords" content="Eiffel class"/>
<meta name="ca_ignore" content="CA011, CA011: too many arguments"/>
<meta name="copyright" content="Copyright (c) 1984-2021, Eiffel Software and others"/>
<meta name="license" content="Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"/>
<meta name="source" content="Eiffel Software 5949 Hollister Ave., Goleta, CA 93117 USA Telephone 805-685-1006, Fax 805-685-6869 Website http://www.eiffel.com Customer support http://support.eiffel.com"/>
<meta name="keywords" content="Eiffel class"/>
<TITLE>routine Text</TITLE></HEAD>
<BODY BGCOLOR="white">
<P ALIGN="CENTER">Automatic generation produced by ISE Eiffel</P>
<PRE><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="routine_chart.html">Chart</A></TD><TD><A HREF="routine_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE><B>note</B>
    description: "[
        Objects representing delayed calls to a routine,
        with some operands possibly still open
    ]"
    library: "Free implementation of ELKS library"
    status: "See notice at end of class."
    legal: "See notice at end of class."
    date: "$Date: 2021-10-04 07:28:32 +0000 (Mon, 04 Oct 2021) $"
    revision: "$Revision: 105810 $"

<B>deferred</B> <B>class</B> 
    <A HREF="../elks/routine.html">ROUTINE</A> [OPEN_ARGS -&gt; <B>detachable</B> <A HREF="../elks/tuple.html">TUPLE</A> <B>create</B> <A HREF="../elks/any.html#f_default_create">default_create</A> <B>end</B>]

<B>inherit</B>
    <A HREF="../elks/hashable.html">HASHABLE</A>
        <B>redefine</B>
            <A HREF="../elks/routine.html#f_copy">copy</A>,
            <A HREF="../elks/routine.html#f_is_equal">is_equal</A>
        <B>end</B>

    <A HREF="../elks/mismatch_corrector.html">MISMATCH_CORRECTOR</A>
        <B>redefine</B>
            <A HREF="../elks/routine.html#f_correct_mismatch">correct_mismatch</A>,
            <A HREF="../elks/routine.html#f_copy">copy</A>,
            <A HREF="../elks/routine.html#f_is_equal">is_equal</A>
        <B>end</B>

<B>inherit</B> {NONE}
    <A HREF="../elks/reflector.html">REFLECTOR</A>
        <B>export</B>
            {NONE} <B>all</B>
        <B>redefine</B>
            <A HREF="../elks/routine.html#f_copy">copy</A>,
            <A HREF="../elks/routine.html#f_is_equal">is_equal</A>
        <B>end</B>

<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialization</FONT>

    <A NAME="f_adapt"><A HREF="../elks/routine.html#f_adapt">adapt</A> (other: <B>like</B> <B>Current</B>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize from </FONT><I>other</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Useful in descendants.</FONT>
        <B>require</B>
            other_exists: other /= <B>Void</B>
            conforming: <A HREF="../elks/any.html#f_conforms_to">conforms_to</A> (other)
        <B>do</B>
            <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A> := other.<A HREF="../elks/routine.html#f_rout_disp">rout_disp</A>
            <A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A> := other.<A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A>
            <A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A> := other.<A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A>
            <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> := other.<A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
            <A HREF="../elks/routine.html#f_operands">operands</A> := other.<A HREF="../elks/routine.html#f_operands">operands</A>
            <A HREF="../elks/routine.html#f_routine_id">routine_id</A> := other.<A HREF="../elks/routine.html#f_routine_id">routine_id</A>
            <A HREF="../elks/routine.html#f_is_basic">is_basic</A> := other.<A HREF="../elks/routine.html#f_is_basic">is_basic</A>
            <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> := other.<A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A>
            <A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A> := other.<A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A>
            <A HREF="../elks/routine.html#f_open_count">open_count</A> := other.<A HREF="../elks/routine.html#f_open_count">open_count</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Access</FONT>

    <A NAME="f_operands"><B>frozen</B> <A HREF="../elks/routine.html#f_operands">operands</A>: <B>detachable</B> OPEN_ARGS</A>

    <A NAME="f_target"><A HREF="../elks/routine.html#f_target">target</A>: <B>detachable</B> <A HREF="../elks/any.html">ANY</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Target of call, if already known</FONT>
        <B>local</B>
            c: <B>like</B> <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
        <B>do</B>
            <B>if</B> <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> <B>then</B>
                c := <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
                <B>if</B> c /= <B>Void</B> <B>and then</B> c.<A HREF="../elks/tuple.html#f_count">count</A> &gt; 0 <B>and then</B> <B>attached</B> {<A HREF="../elks/any.html">ANY</A>} c.<A HREF="../elks/tuple.html#f_item">item</A> (1) <B>as</B> r <B>then</B>
                    <B>Result</B> := r
                <B>end</B>
            <B>elseif</B> <B>attached</B> {<A HREF="../elks/tuple.html">TUPLE</A>} <A HREF="../elks/routine.html#f_operands">operands</A> <B>as</B> o <B>and then</B> o.<A HREF="../elks/tuple.html#f_count">count</A> &gt; 0 <B>and then</B> <B>attached</B> {<A HREF="../elks/any.html">ANY</A>} o.<A HREF="../elks/tuple.html#f_item">item</A> (1) <B>as</B> r <B>then</B>
                <B>Result</B> := r
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_hash_code"><A HREF="../elks/routine.html#f_hash_code">hash_code</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Hash code value.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A>.<A HREF="../elks/pointer.html#f_hash_code">hash_code</A>.<A HREF="../elks/integer_32.html#f_bit_xor">bit_xor</A> (<A HREF="../elks/routine.html#f_routine_id">routine_id</A>.<A HREF="../elks/integer_32_ref.html#f_hash_code">hash_code</A>)
        <B>end</B></A>

    <A NAME="f_precondition"><A HREF="../elks/routine.html#f_precondition">precondition</A> (args: <B>like</B> <A HREF="../elks/routine.html#f_operands">operands</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Do </FONT><I>args</I><FONT COLOR="red"> satisfy routine's precondition</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> in current state?</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
        <B>end</B></A>

    <A NAME="f_postcondition"><A HREF="../elks/routine.html#f_postcondition">postcondition</A> (args: <B>like</B> <A HREF="../elks/routine.html#f_operands">operands</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Does current state satisfy routine's</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> postcondition for </FONT><I>args</I><FONT COLOR="red">?</FONT>
        <B>do</B>
            <B>Result</B> := <B>True</B>
        <B>end</B></A>

    <A NAME="f_empty_operands"><A HREF="../elks/routine.html#f_empty_operands">empty_operands</A>: <B>attached</B> OPEN_ARGS
        <B>obsolete</B> "This function will be removed as non-void-safe. [2017-05-31]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Empty tuple matching open operands.</FONT>
        <B>do</B>
            <B>create</B> <B>Result</B>
        <B>ensure</B>
            empty_operands_not_void: <B>Result</B> /= <B>Void</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Status report</FONT>

    <A NAME="f_callable"><A HREF="../elks/routine.html#f_callable">Callable</A>: <A HREF="../elks/boolean.html">BOOLEAN</A> = <B>True</B></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Can routine be called on current object?</FONT>

    <A NAME="f_is_equal"><A HREF="../elks/routine.html#f_is_equal">is_equal</A> (other: <B>like</B> <B>Current</B>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is associated routine the same as the one</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> associated with </FONT><I>other</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> ~ other.<A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> <B>and then</B> <A HREF="../elks/routine.html#f_operands">operands</A> ~ other.<A HREF="../elks/routine.html#f_operands">operands</A> <B>and then</B> <A HREF="../elks/routine.html#f_open_map">open_map</A> ~ other.<A HREF="../elks/routine.html#f_open_map">open_map</A> <B>and then</B> (<A HREF="../elks/routine.html#f_rout_disp">rout_disp</A> = other.<A HREF="../elks/routine.html#f_rout_disp">rout_disp</A>) <B>and then</B> (<A HREF="../elks/routine.html#f_routine_id">routine_id</A> = other.<A HREF="../elks/routine.html#f_routine_id">routine_id</A>) <B>and then</B> (<A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A> = other.<A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A>) <B>and then</B> (<A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A> = other.<A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A>) <B>and then</B> (<A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A> = other.<A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A>)
        <B>end</B></A>

    <A NAME="f_valid_operands"><A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (args: <B>detachable</B> <B>separate</B> <A HREF="../elks/tuple.html">TUPLE</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Are </FONT><I>args</I><FONT COLOR="red"> valid operands for this routine?</FONT>
        <B>local</B>
            i, arg_type_code: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            arg: <B>like</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_item">item</A>
            l_type: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> args = <B>Void</B> <B>then</B>
                <B>Result</B> := <A HREF="../elks/routine.html#f_open_count">open_count</A> = 0
            <B>elseif</B> args.<A HREF="../elks/tuple.html#f_count">count</A> &gt;= <A HREF="../elks/routine.html#f_open_count">open_count</A> <B>then</B>
                <B>from</B>
                    <B>Result</B> := <B>True</B>
                    i := 1
                <B>until</B>
                    i &gt; <A HREF="../elks/routine.html#f_open_count">open_count</A> <B>or</B> <B>not</B> <B>Result</B>
                <B>loop</B>
                    arg_type_code := args.<A HREF="../elks/tuple.html#f_item_code">item_code</A> (i).<A HREF="../elks/natural_8_ref.html#f_to_integer_32">to_integer_32</A>
                    l_type := <A HREF="../elks/routine.html#f_open_operand_type">open_operand_type</A> (i)
                    <B>inspect</B> arg_type_code
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_boolean_code">boolean_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/boolean.html">BOOLEAN</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_character_8_code">character_8_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/character_8.html">CHARACTER_8</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_character_32_code">character_32_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/character_32.html">CHARACTER_32</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_integer_8_code">integer_8_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/integer_8.html">INTEGER_8</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_integer_16_code">integer_16_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/integer_16.html">INTEGER_16</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_integer_32_code">integer_32_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/integer_32.html">INTEGER_32</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_integer_64_code">integer_64_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/integer_64.html">INTEGER_64</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_natural_8_code">natural_8_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/natural_8.html">NATURAL_8</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_natural_16_code">natural_16_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/natural_16.html">NATURAL_16</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_natural_32_code">natural_32_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/natural_32.html">NATURAL_32</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_natural_64_code">natural_64_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/natural_64.html">NATURAL_64</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_pointer_code">pointer_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/pointer.html">POINTER</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_real_32_code">real_32_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/real_32.html">REAL_32</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_real_64_code">real_64_code</A> <B>then</B>
                        <B>Result</B> := l_type = ({<A HREF="../elks/real_64.html">REAL_64</A>}).<A HREF="../elks/type.html#f_type_id">type_id</A>
                    <B>when</B> {<A HREF="../elks/tuple.html">TUPLE</A>}.<A HREF="../elks/tuple.html#f_reference_code">reference_code</A> <B>then</B>
                        arg := args.<A HREF="../elks/tuple.html#f_item">item</A> (i)
                        <B>if</B> <A HREF="../elks/reflector.html#f_is_attached_type">is_attached_type</A> (l_type) <B>then</B>
                            <B>Result</B> := arg /= <B>Void</B> <B>and then</B> <A HREF="../elks/reflector.html#f_field_conforms_to">field_conforms_to</A> ({<A HREF="../elks/ise_runtime.html">ISE_RUNTIME</A>}.<A HREF="../elks/ise_runtime.html#f_dynamic_type">dynamic_type</A> (arg), l_type)
                        <B>else</B>
                            <B>Result</B> := arg = <B>Void</B> <B>or else</B> <A HREF="../elks/reflector.html#f_field_conforms_to">field_conforms_to</A> ({<A HREF="../elks/ise_runtime.html">ISE_RUNTIME</A>}.<A HREF="../elks/ise_runtime.html#f_dynamic_type">dynamic_type</A> (arg), l_type)
                        <B>end</B>
                    <B>else</B>
                        <B>Result</B> := <B>False</B>
                    <B>end</B>
                    i := i + 1
                <B>end</B>
            <B>end</B>
            <B>if</B> <B>Result</B> <B>and then</B> <B>not</B> <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> <B>then</B>
                <B>Result</B> := args /= <B>Void</B> <B>and then</B> <B>not</B> args.<A HREF="../elks/tuple.html#f_is_empty">is_empty</A> <B>and then</B> args.<A HREF="../elks/tuple.html#f_item">item</A> (1) /= <B>Void</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_valid_target"><A HREF="../elks/routine.html#f_valid_target">valid_target</A> (args: <B>detachable</B> <A HREF="../elks/tuple.html">TUPLE</A>): <A HREF="../elks/boolean.html">BOOLEAN</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is the first element of tuple </FONT><I>args</I><FONT COLOR="red"> a valid target</FONT>
        <B>do</B>
            <B>if</B> args /= <B>Void</B> <B>and then</B> args.<A HREF="../elks/tuple.html#f_count">count</A> &gt; 0 <B>then</B>
                <B>if</B> args.<A HREF="../elks/tuple.html#f_is_reference_item">is_reference_item</A> (1) <B>then</B>
                    <B>Result</B> := args.<A HREF="../elks/tuple.html#f_reference_item">reference_item</A> (1) /= <B>Void</B>
                <B>else</B>
                    <B>Result</B> := <B>True</B>
                <B>end</B>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_is_target_closed"><A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A>: <A HREF="../elks/boolean.html">BOOLEAN</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Is target for current agent closed, i.e. specified at creation time?</FONT>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Measurement</FONT>

    <A NAME="f_open_count"><A HREF="../elks/routine.html#f_open_count">open_count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Number of open operands.</FONT>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Settings</FONT>

    <A NAME="f_set_operands"><B>frozen</B> <A HREF="../elks/routine.html#f_set_operands">set_operands</A> (args: <B>detachable</B> OPEN_ARGS)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use </FONT><I>args</I><FONT COLOR="red"> as operands for next call.</FONT>
        <B>require</B>
            valid_operands: <A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (args)
        <B>do</B>
            <A HREF="../elks/routine.html#f_operands">operands</A> := args
        <B>ensure</B>
            operands_set: (<A HREF="../elks/routine.html#f_operands">operands</A> /= <B>Void</B> <B>implies</B> (<A HREF="../elks/routine.html#f_operands">operands</A> ~ args)) <B>or</B> (<A HREF="../elks/routine.html#f_operands">operands</A> = <B>Void</B> <B>implies</B> (args = <B>Void</B> <B>or else</B> args.<A HREF="../elks/tuple.html#f_is_empty">is_empty</A>))
        <B>end</B></A>

    <A NAME="f_set_target"><A HREF="../elks/routine.html#f_set_target">set_target</A> (a_target: <B>like</B> <A HREF="../elks/routine.html#f_target">target</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Set </FONT><I>a_target</I><FONT COLOR="red"> as the next </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/routine.html#f_target">target</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> for remaining calls to Current.</FONT>
        <B>require</B>
            a_target_not_void: a_target /= <B>Void</B>
            is_target_closed: <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A>
            target_not_void: <A HREF="../elks/routine.html#f_target">target</A> /= <B>Void</B>
            same_target_type: <B>attached</B> <A HREF="../elks/routine.html#f_target">target</A> <B>as</B> t <B>and then</B> t.<A HREF="../elks/any.html#f_same_type">same_type</A> (a_target)
        <B>local</B>
            c: <B>like</B> <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
        <B>do</B>
            c := <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
            <B>if</B> c /= <B>Void</B> <B>then</B>
                c.<A HREF="../elks/tuple.html#f_put">put</A> (a_target, 1)
            <B>end</B>
        <B>ensure</B>
            target_set: <A HREF="../elks/routine.html#f_target">target</A> = a_target
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Duplication</FONT>

    <A NAME="f_copy"><A HREF="../elks/routine.html#f_copy">copy</A> (other: <B>like</B> <B>Current</B>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Use same routine as </FONT><I>other</I><FONT COLOR="red">.</FONT>
        <B>do</B>
            <B>if</B> other /= <B>Current</B> <B>then</B>
                <A HREF="../elks/any.html#f_standard_copy">standard_copy</A> (other)
                <B>if</B> <B>attached</B> <A HREF="../elks/routine.html#f_operands">operands</A> <B>as</B> l_operands <B>then</B>
                    <A HREF="../elks/routine.html#f_operands">operands</A> := l_operands.<A HREF="../elks/any.html#f_twin">twin</A>
                <B>end</B>
            <B>end</B>
        <B>ensure then</B>
            same_call_status: other.<A HREF="../elks/routine.html#f_callable">Callable</A> <B>implies</B> <A HREF="../elks/routine.html#f_callable">Callable</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Basic operations</FONT>

    <A NAME="f_call"><A HREF="../elks/routine.html#f_call">call</A> (args: <B>detachable</B> <B>separate</B> OPEN_ARGS)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Call routine with </FONT><I>args</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            valid_operands: <A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (args)
        <B>deferred</B>
        <B>end</B></A>

    <A NAME="f_apply"><A HREF="../elks/routine.html#f_apply">apply</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Call routine with </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/routine.html#f_operands">operands</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> as last set.</FONT>
        <B>require</B>
            valid_operands: <A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (<A HREF="../elks/routine.html#f_operands">operands</A>)
        <B>deferred</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Extended operations</FONT>

    <A NAME="f_flexible_call"><A HREF="../elks/routine.html#f_flexible_call">flexible_call</A> (a: <B>detachable</B> <B>separate</B> <A HREF="../elks/tuple.html">TUPLE</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Call routine with arguments </FONT><I>a</I><FONT COLOR="red">.</FONT>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Compared to </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/routine.html#f_call">call</A><FONT COLOR="red">`</FONT><FONT COLOR="red"> the type of </FONT><I>a</I><FONT COLOR="red"> may be different from </FONT><FONT COLOR="red">`</FONT><FONT COLOR="red">{</FONT><A HREF="../elks/routine.html">ROUTINE</A> [Generic #1]<FONT COLOR="red">}</FONT><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>require</B>
            valid_operands: <A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (a)
        <B>local</B>
            default_arguments: <B>detachable</B> OPEN_ARGS
            i: <A HREF="../elks/integer_32.html">INTEGER_32</A>
        <B>do</B>
            <B>if</B> <B>not</B> <B>attached</B> a <B>then</B>
                <A HREF="../elks/routine.html#f_call">call</A> (default_arguments)
            <B>elseif</B> <B>attached</B> {OPEN_ARGS} a <B>as</B> x <B>then</B>
                <A HREF="../elks/routine.html#f_call">call</A> (x)
            <B>else</B>
                <B>check</B>
                    from_precondition: <B>attached</B> {OPEN_ARGS} ({<A HREF="../elks/ise_runtime.html">ISE_RUNTIME</A>}.<A HREF="../elks/ise_runtime.html#f_new_tuple_instance_of">new_tuple_instance_of</A> (({OPEN_ARGS}).<A HREF="../elks/type.html#f_type_id">type_id</A>)) <B>as</B> x
                <B>then</B>
                    <B>if</B> a.<A HREF="../elks/tuple.html#f_object_comparison">object_comparison</A> <B>then</B>
                        x.<A HREF="../elks/tuple.html#f_compare_objects">compare_objects</A>
                    <B>end</B>
                    <B>from</B>
                        i := x.<A HREF="../elks/tuple.html#f_count">count</A>
                    <B>until</B>
                        i &lt;= 0
                    <B>loop</B>
                        x [i] := a [i]
                        i := i - 1
                    <B>end</B>
                    <A HREF="../elks/routine.html#f_call">call</A> (x)
                <B>end</B>
            <B>end</B>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Correction</FONT>

    <A NAME="f_correct_mismatch"><A HREF="../elks/routine.html#f_correct_mismatch">correct_mismatch</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Attempt to correct object mismatch using </FONT><FONT COLOR="red">`</FONT><A HREF="../elks/mismatch_corrector.html#f_mismatch_information">mismatch_information</A><FONT COLOR="red">`</FONT><FONT COLOR="red">.</FONT>
        <B>do</B>
        <B>end</B></A>
    
<B>feature</B> {<A HREF="../elks/routine.html">ROUTINE</A>} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_closed_operands"><B>frozen</B> <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>: <B>detachable</B> <A HREF="../elks/tuple.html">TUPLE</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> All closed arguments provided at creation time</FONT>

    <A NAME="f_closed_count"><A HREF="../elks/routine.html#f_closed_count">closed_count</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> The number of closed operands (including the target if it is closed)</FONT>
        <B>local</B>
            c: <B>detachable</B> <A HREF="../elks/tuple.html">TUPLE</A>
        <B>do</B>
            c := <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A>
            <B>if</B> c /= <B>Void</B> <B>then</B>
                <B>Result</B> := c.<A HREF="../elks/tuple.html#f_count">count</A>
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_rout_disp"><B>frozen</B> <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A>: <A HREF="../elks/pointer.html">POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Routine dispatcher</FONT>

    <A NAME="f_calc_rout_addr"><B>frozen</B> <A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A>: <A HREF="../elks/pointer.html">POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Address of the final routine</FONT>

    <A NAME="f_open_map"><B>frozen</B> <A HREF="../elks/routine.html#f_open_map">open_map</A>: <B>detachable</B> <A HREF="../elks/array.html">ARRAY</A> [<A HREF="../elks/integer_32.html">INTEGER_32</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Index map for open arguments</FONT>

    <A NAME="f_encaps_rout_disp"><B>frozen</B> <A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A>: <A HREF="../elks/pointer.html">POINTER</A></A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Eiffel routine dispatcher</FONT>

    <A NAME="f_routine_id"><B>frozen</B> <A HREF="../elks/routine.html#f_routine_id">routine_id</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>

    <A NAME="f_is_basic"><B>frozen</B> <A HREF="../elks/routine.html#f_is_basic">is_basic</A>: <A HREF="../elks/boolean.html">BOOLEAN</A></A>

    <A NAME="f_written_type_id_inline_agent"><B>frozen</B> <A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A>: <A HREF="../elks/integer_32.html">INTEGER_32</A></A>

    <A NAME="f_set_rout_disp"><B>frozen</B> <A HREF="../elks/routine.html#f_set_rout_disp">set_rout_disp</A> (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: <A HREF="../elks/pointer.html">POINTER</A>; a_routine_id: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_open_map: <B>like</B> <A HREF="../elks/routine.html#f_open_map">open_map</A>; a_is_basic, a_is_target_closed: <A HREF="../elks/boolean.html">BOOLEAN</A>; a_written_type_id_inline_agent: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_closed_operands: <A HREF="../elks/tuple.html">TUPLE</A>; a_open_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize object in workbench mode.</FONT>
        <B>require</B>
            a_routine_id_valid: a_routine_id &gt; -1
            target_valid: a_is_target_closed <B>implies</B> <A HREF="../elks/routine.html#f_valid_target">valid_target</A> (a_closed_operands)
        <B>do</B>
            <A HREF="../elks/routine.html#f_set_rout_disp_int">set_rout_disp_int</A> (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr, a_routine_id, a_open_map, a_is_basic, a_is_target_closed, a_written_type_id_inline_agent, a_closed_operands, a_open_count)
        <B>end</B></A>

    <A NAME="f_set_rout_disp_final"><B>frozen</B> <A HREF="../elks/routine.html#f_set_rout_disp_final">set_rout_disp_final</A> (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: <A HREF="../elks/pointer.html">POINTER</A>; a_closed_operands: <A HREF="../elks/tuple.html">TUPLE</A>; a_is_target_closed: <A HREF="../elks/boolean.html">BOOLEAN</A>; a_open_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize object in finalized mode.</FONT>
        <B>require</B>
            target_valid: a_is_target_closed <B>implies</B> <A HREF="../elks/routine.html#f_valid_target">valid_target</A> (a_closed_operands)
        <B>do</B>
            <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A> := a_rout_disp
            <A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A> := a_encaps_rout_disp
            <A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A> := a_calc_rout_addr
            <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> := a_closed_operands
            <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> := a_is_target_closed
            <A HREF="../elks/routine.html#f_open_count">open_count</A> := a_open_count
        <B>end</B></A>

    <A NAME="f_set_rout_disp_int"><B>frozen</B> <A HREF="../elks/routine.html#f_set_rout_disp_int">set_rout_disp_int</A> (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: <A HREF="../elks/pointer.html">POINTER</A>; a_routine_id: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_open_map: <B>like</B> <A HREF="../elks/routine.html#f_open_map">open_map</A>; a_is_basic, a_is_target_closed: <A HREF="../elks/boolean.html">BOOLEAN</A>; a_written_type_id_inline_agent: <A HREF="../elks/integer_32.html">INTEGER_32</A>; a_closed_operands: <A HREF="../elks/tuple.html">TUPLE</A>; a_open_count: <A HREF="../elks/integer_32.html">INTEGER_32</A>)
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Initialize object in workbench mode.</FONT>
        <B>require</B>
            a_routine_id_valid: a_routine_id &gt; -1
            target_valid: a_is_target_closed <B>implies</B> <A HREF="../elks/routine.html#f_valid_target">valid_target</A> (a_closed_operands)
        <B>do</B>
            <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A> := a_rout_disp
            <A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A> := a_encaps_rout_disp
            <A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A> := a_calc_rout_addr
            <A HREF="../elks/routine.html#f_routine_id">routine_id</A> := a_routine_id
            <A HREF="../elks/routine.html#f_open_map">open_map</A> := a_open_map
            <A HREF="../elks/routine.html#f_is_basic">is_basic</A> := a_is_basic
            <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> := a_is_target_closed
            <A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A> := a_written_type_id_inline_agent
            <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> := a_closed_operands
            <A HREF="../elks/routine.html#f_open_count">open_count</A> := a_open_count
        <B>ensure</B>
            rout_disp_set: <A HREF="../elks/routine.html#f_rout_disp">rout_disp</A> = a_rout_disp
            encaps_rout_disp_set: <A HREF="../elks/routine.html#f_encaps_rout_disp">encaps_rout_disp</A> = a_encaps_rout_disp
            calc_rout_addr_set: <A HREF="../elks/routine.html#f_calc_rout_addr">calc_rout_addr</A> = a_calc_rout_addr
            routine_id_set: <A HREF="../elks/routine.html#f_routine_id">routine_id</A> = a_routine_id
            open_map_set: <A HREF="../elks/routine.html#f_open_map">open_map</A> = a_open_map
            is_target_closed_set: <A HREF="../elks/routine.html#f_is_target_closed">is_target_closed</A> = a_is_target_closed
            is_basic_set: <A HREF="../elks/routine.html#f_is_basic">is_basic</A> = a_is_basic
            written_type_id_inline_agent_set: <A HREF="../elks/routine.html#f_written_type_id_inline_agent">written_type_id_inline_agent</A> = a_written_type_id_inline_agent
            closed_operands_set: <A HREF="../elks/routine.html#f_closed_operands">closed_operands</A> = a_closed_operands
            open_count_set: <A HREF="../elks/routine.html#f_open_count">open_count</A> = a_open_count
        <B>end</B></A>
    
<B>feature</B> {NONE} <FONT COLOR="red">--</FONT><FONT COLOR="red"> Implementation</FONT>

    <A NAME="f_open_types"><B>frozen</B> <A HREF="../elks/routine.html#f_open_types">open_types</A>: <B>detachable</B> <A HREF="../elks/array.html">ARRAY</A> [<A HREF="../elks/integer_32.html">INTEGER_32</A>]</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Types of open operands</FONT>

    <A NAME="f_open_operand_type"><A HREF="../elks/routine.html#f_open_operand_type">open_operand_type</A> (i: <A HREF="../elks/integer_32.html">INTEGER_32</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type of </FONT><I>i</I><FONT COLOR="red">th open operand.</FONT>
        <B>require</B>
            positive: i &gt;= 1
            within_bounds: i &lt;= <A HREF="../elks/routine.html#f_open_count">open_count</A>
        <B>local</B>
            o: <B>like</B> <A HREF="../elks/routine.html#f_open_types">open_types</A>
        <B>do</B>
            o := <A HREF="../elks/routine.html#f_open_types">open_types</A>
            <B>if</B> o = <B>Void</B> <B>then</B>
                <B>create</B> o.<A HREF="../elks/array.html#f_make_filled">make_filled</A> (-1, 1, <A HREF="../elks/routine.html#f_open_count">open_count</A>)
                <A HREF="../elks/routine.html#f_open_types">open_types</A> := o
            <B>end</B>
            <B>Result</B> := o.<A HREF="../elks/array.html#f_item">item</A> (i)
            <B>if</B> <B>Result</B> = -1 <B>then</B>
                <B>Result</B> := ({OPEN_ARGS}).<A HREF="../elks/type.html#f_generic_parameter_type">generic_parameter_type</A> (i).<A HREF="../elks/type.html#f_type_id">type_id</A>;
                o.<A HREF="../elks/array.html#f_put">put</A> (<B>Result</B>, i)
            <B>end</B>
        <B>end</B></A>

    <A NAME="f_type_id_of"><A HREF="../elks/routine.html#f_type_id_of">type_id_of</A> (a: <B>separate</B> <A HREF="../elks/any.html">ANY</A>): <A HREF="../elks/integer_32.html">INTEGER_32</A>
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Type ID of an object </FONT><I>a</I><FONT COLOR="red">.</FONT>
        <B>require</B>
            <B>False</B>
        <B>do</B>
            <B>Result</B> := a.<A HREF="../elks/any.html#f_generating_type">generating_type</A>.<A HREF="../elks/type.html#f_type_id">type_id</A>
        <B>end</B></A>
    
<B>feature</B> <FONT COLOR="red">--</FONT><FONT COLOR="red"> Obsolete</FONT>

    <A NAME="f_adapt_from"><A HREF="../elks/routine.html#f_adapt_from">adapt_from</A> (other: <B>like</B> <B>Current</B>)
        <B>obsolete</B> "Please use `adapt' instead (it's also a creation procedure).  [2017-05-31]"
            <FONT COLOR="red">--</FONT><FONT COLOR="red"> Adapt from </FONT><I>other</I><FONT COLOR="red">. Useful in descendants.</FONT>
        <B>require</B>
            other_exists: other /= <B>Void</B>
            conforming: <A HREF="../elks/any.html#f_conforms_to">conforms_to</A> (other)
        <B>do</B>
            <A HREF="../elks/routine.html#f_adapt">adapt</A> (other)
        <B>end</B></A>

    <A NAME="f_arguments"><A HREF="../elks/routine.html#f_arguments">arguments</A>: <B>detachable</B> OPEN_ARGS
        <B>obsolete</B> "Use `operands`. [2017-05-31]"
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/routine.html#f_operands">operands</A>
        <B>end</B></A>

    <A NAME="f_set_arguments"><A HREF="../elks/routine.html#f_set_arguments">set_arguments</A> (args: <B>detachable</B> OPEN_ARGS)
        <B>obsolete</B> "Use `set_operands`. [2017-05-31]"
        <B>do</B>
            <A HREF="../elks/routine.html#f_set_operands">set_operands</A> (args)
        <B>end</B></A>

    <A NAME="f_valid_arguments"><A HREF="../elks/routine.html#f_valid_arguments">valid_arguments</A> (args: <B>detachable</B> OPEN_ARGS): <A HREF="../elks/boolean.html">BOOLEAN</A>
        <B>obsolete</B> "Use `valid_operands`. [2017-05-31]"
        <B>do</B>
            <B>Result</B> := <A HREF="../elks/routine.html#f_valid_operands">valid_operands</A> (args)
        <B>end</B></A>
    
<B>note</B>
    ca_ignore: "CA011", "CA011: too many arguments"
    copyright: "Copyright (c) 1984-2021, Eiffel Software and others"
    license: "Eiffel Forum License v2 (see <a href="http://www.eiffel.com/licensing/forum.txt">http://www.eiffel.com/licensing/forum.txt</a>)"
    source: "[
        Eiffel Software
        5949 Hollister Ave., Goleta, CA 93117 USA
        Telephone 805-685-1006, Fax 805-685-6869
        Website <a href="http://www.eiffel.com">http://www.eiffel.com</a>
        Customer support <a href="http://support.eiffel.com">http://support.eiffel.com</a>
    ]"

<B>end</B> <FONT COLOR="red">--</FONT> <FONT COLOR="red">class </FONT><A HREF="../elks/routine.html">ROUTINE</A><TABLE BORDER="1" ALIGN="CENTER"><TR><TD><A HREF="../class_list.html">Classes</A></TD><TD><A HREF="../cluster_list.html">Clusters</A></TD><TD><A HREF="../cluster_hierarchy.html">Cluster hierarchy</A></TD><TD><A HREF="routine_chart.html">Chart</A></TD><TD><A HREF="routine_links.html">Relations</A></TD><TD>Text</TD></TR></TABLE></PRE>
<P ALIGN="CENTER"> &#045;&#045; Generated by ISE Eiffel &#045;&#045 </P>
<P ALIGN="CENTER">For more details: <A HREF="http://www.eiffel.com">www.eiffel.com</A></P>
</BODY>
</HTML>

